<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="../../_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B Data Sagas</title>
    
    
    <!-- MathJax -->
    <script>
        window.MathJax = {
            loader: {
                load: ['[tex]/cancel', '[tex]/braket']
            },
            tex: {
                inlineMath: [
                    ['$', '$']
                ],
                packages: {
                    '[+]': ['cancel', 'braket', 'marvosym']
                },
                macros: {
                    blank:    "{\\underline{\\phantom{\\_\\_\\_\\_\\_}}}",
                    floor:    ["{\\left\\lfloor {#1} \\right\\rfloor}", 1],
                    ceil:     [ "{\\left\\lceil {#1} \\right\\rceil}", 1],
                    abs:      [ "{\\left\\vert {#1} \\right\\vert}", 1],
                    powerset: [ "{\\wp\\left( {#1} \\right)}", 1],
                    suchthat: "{\\ \\vert \\ }",
                    cfgor:    "{\\ \\vert \\ }",
                    naturals: "{\\mathbb{N}}",
                    integers: "{\\mathbb{Z}}",
                    reals:    "{\\mathbb{R}}",
                    qed:      "{\\blacksquare}",
                    phibar:   "{\\overline{\\varphi}}",
                    accepts:  "{\\text{ accepts }}",
                    rejects:  "{\\text{ rejects }}",
                    loopson:  "{\\text{ loops on }}",
                    haltson:  "{\\text{ halts on }}",
                    encoded:  [ "{\\left\\langle {#1} \\right\\rangle}", 1],
                    rlangs:   "\\mathbf{R}",
                    relangs:  "\\mathbf{RE}",
                    corelangs:"\\text{co-}\\mathbf{RE}",
                    plangs:   "\\mathbf{P}",
                    nplangs:  "\\mathbf{NP}"
                }
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
    <nav class="navbar navbar-expand-md navbar-dark" role="navigation">
  <a class="navbar-brand" href="../../index.html">üè†CS106B </a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="navbar-collapse collapse"  id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Course Admin </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../syllabus.html">Syllabus</a>
            
            
            
              <a class="dropdown-item" href="../../course_placement.html">Course Placement Guide</a>
            
            
            
              <a class="dropdown-item" href="../../honor_code.html">Honor Code</a>
            
            
            
              <a class="dropdown-item" href="../../about_staff.html">Teaching Team</a>
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Resources </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../lair.html">LaIR</a>
            
            
            
              <a class="dropdown-item" href="../../about_partners.html">Guide to Partners</a>
            
            
            
              <a class="dropdown-item" href="https://edstem.org/us/courses/16604/discussion/">Ed Discussion Forum</a>
            
            
            
              <a class="dropdown-item" href="https://cs198.stanford.edu/paperless">Paperless</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/dept/cs_edu/resources/qt/">Qt Installation Guide</a>
            
            
            
              <a class="dropdown-item" href="http://en.cppreference.com/">C++ Reference</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/">Stanford Library Documentation</a>
            
            
            
              <a class="dropdown-item" href="https://docs.google.com/document/d/12cXSV84N9lhU-4tsdEmNJRlSBcwwDpsaAePWP15RUjU/">String Reference Guide</a>
            
            
            
              <a class="dropdown-item" href="../../resources/style_guide.html">Style Guide</a>
            
            
            
              <a class="dropdown-item" href="../../resources/testing_guide.html">Testing Guide</a>
            
            
            
              <a class="dropdown-item" href="../../resources/debugging_guide.html">Debugging Guide</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1224/resources/bigo_guide.html">Guide to Big-O Notation</a>
            
            
            
              <a class="dropdown-item" href="../../resources/python_to_cpp.html">Python to C++ Guide</a>
            
            
            
              <a class="dropdown-item" href="../../resources/submit_checklist.html">Submission Checklist</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/dept/cs_edu/resources/textbook/">Textbook</a>
            
            
            
              <a class="dropdown-item" href="../../how_to_improve.html">How to Improve</a>
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Lectures </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../about_lectures.html">About Lectures</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../lectures/00-welcome/index.html">  0.  1/3 Introduction </a>
                
                  <a class="dropdown-item" href="../../lectures/01-functions/index.html">  1.  1/5 Functions in C++ </a>
                
                  <a class="dropdown-item" href="../../lectures/02-strings/index.html">  2.  1/7 Strings in C++ </a>
                
                  <a class="dropdown-item" href="../../lectures/03-collections-1/index.html">  3.  1/10 Containers, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/04-collections-2/index.html">  4.  1/12 Containers, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/05-collections-3/index.html">  5.  1/14 Containers, Part III </a>
                
                  <a class="dropdown-item" href="../../lectures/06-recursion-1/index.html">  6.  1/19 Thinking Recursively, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/07-recursion-2/index.html">  7.  1/21 Thinking Recursively, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/08-recursion-3/index.html">  8.  1/24 Thinking Recursively, Part III </a>
                
                  <a class="dropdown-item" href="../../lectures/09-recursion-4/index.html">  9.  1/26 Thinking Recursively, Part IV </a>
                
                  <a class="dropdown-item" href="../../lectures/10-recursion-5/index.html">  10.  1/28 Thinking Recursively, Part V </a>
                
                  <a class="dropdown-item" href="../../lectures/11-big-o/index.html">  11.  1/31 Big-O Notation </a>
                
                  <a class="dropdown-item" href="../../lectures/12-searching-sorting-1/index.html">  12.  2/2 Searching and Sorting, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/13-searching-sorting-2/index.html">  13.  2/4 Searching and Sorting, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/14-designing-abstractions/index.html">  14.  2/7 Designing Abstractions </a>
                
                  <a class="dropdown-item" href="../../lectures/15-implementing-abstractions-1/index.html">  15.  2/9 Implementing Abstractions, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/16-implementing-abstractions-2/index.html">  16.  2/11 Implementing Abstractions, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/17-hashing-1/index.html">  17.  2/14 Hashing, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/18-ethics/index.html">  18.  2/16 Applied Ethics </a>
                
                  <a class="dropdown-item" href="../../lectures/19-hashing-2/index.html">  19.  2/18 Hashing, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/20-linked-lists-1/index.html">  20.  2/23 Linked Lists, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/21-linked-lists-2/index.html">  21.  2/25 Linked Lists, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/22-bsts-1/index.html">  22.  2/28 Binary Search Trees, Part I </a>
                
                  <a class="dropdown-item" href="../../lectures/23-bsts-2/index.html">  23.  3/2 Binary Search Trees, Part II </a>
                
                  <a class="dropdown-item" href="../../lectures/24-beyond-data-structures/index.html">  24.  3/4 Beyond Data Structures </a>
                
                  <a class="dropdown-item" href="../../lectures/25-graphs.html">  25.  3/7 Graphs </a>
                
                  <a class="dropdown-item" href="../../lectures/26-msts.html">  26.  3/9 Minimum Spanning Trees </a>
                
                  <a class="dropdown-item" href="../../lectures/27-where-to-go-from-here/index.html">  27.  3/11 Where to Go From Here </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Assignments </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../about_assignments.html">About Assignments</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../a0/index.html">  0.   Welcome to CS106B! </a>
                
                  <a class="dropdown-item" href="../a1/index.html">  1.   Welcome to C++! </a>
                
                  <a class="dropdown-item" href="../a2/index.html">  2.   Fun with Collections </a>
                
                  <a class="dropdown-item" href="../a3/index.html">  3.   Recursion! </a>
                
                  <a class="dropdown-item" href="../a4/index.html">  4.   Recursion to the Rescue! </a>
                
                  <a class="dropdown-item" href="../a5/index.html">  5.   Bag'O Big-O </a>
                
                  <a class="dropdown-item" href="index.html">  6.   Data Sagas </a>
                
                  <a class="dropdown-item" href="../a7/index.html">  7.   The Great Stanford Hash-Off </a>
                
                  <a class="dropdown-item" href="../a8/index.html">  8.   The Adventures of Links </a>
                
                  <a class="dropdown-item" href="../a9/index.html">  9.   Huffman Coding </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Sections </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../about_section.html">About Sections</a>
            
            
            
              <a class="dropdown-item" href="https://cs198.stanford.edu/cs198/auth/default.aspx">Section Portal</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../section/section1/index.html">  1.   C++ fundamentals </a>
                
                  <a class="dropdown-item" href="../../section/section2/index.html">  2.   Containers </a>
                
                  <a class="dropdown-item" href="../../section/section3/index.html">  3.   Recursion Etudes </a>
                
                  <a class="dropdown-item" href="../../section/section4/index.html">  4.   Recursive Backtracking </a>
                
                  <a class="dropdown-item" href="../../section/section5/index.html">  5.   Class Design and Dynamic Memory Allocation </a>
                
                  <a class="dropdown-item" href="../../section/section6/index.html">  6.   Class Design and Hashing </a>
                
                  <a class="dropdown-item" href="../../section/section7/index.html">  7.   Linked Lists </a>
                
                  <a class="dropdown-item" href="../../section/section8/index.html">  8.   Trees </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Exams </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../midterm_logistics.html">Midterm Logistics</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../exams/1-midterm/index.html">  1.   Midterm Exam </a>
                
                  <a class="dropdown-item" href="../../exams/2-final/index.html">  2.   Final Exam </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../schedule.html">üóìSchedule</a></li>
        
      
    </ul>
    <!---
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" id="search-text" name="query" placeholder="üîç Search CS106B..." aria-label="Search" action="search">
    </form>
    --->
  </div>
</nav>

<style>
  .navbar {
    margin-bottom: 2rem;
  }
  .navbar-dark {
    background-color: #444;
  }
 .nav-item > a {
    text-transform: uppercase;
    letter-spacing: .08rem;
    font-size: small;
    color: #bbb !important;
  }
  .nav-item > a:hover {
    color: white !important;
  }
</style>
    <div class="alert alert-warning text-center mx-auto p-2">
    <big>‚ö†Ô∏è This page is not current. It is an archive from Winter Quarter 2022.</big>
</div>

    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">Assignment 6. Data Sagas</h1>

<hr>

<p class="attribution">

</p>


    <div class="row">
        <div class="col-xs-12 col-md-10" id="content"<>
<style>
h4 {
    margin-top: 2rem;
}
</style>

<!-- This boilerplate inserts formatted due date -->

<!--  Boilerplate content for assignment index page -->

<h2 id="due-friday-february-18-at-1030-am">Due Friday, February 18 at 10:30 am</h2>

<ul>
  <li><small>Submissions received by the due date receive a small <strong>on-time bonus</strong>. </small></li>
  <li><small>All students are granted a pre-approved extension or "grace period" of 24 hours after the due date. Late submissions are accepted during the grace period with no penalty.</small></li>
  <li><small>The <strong>grace period expires Sat, Feb 19 at 10:30 am</strong>, after which we cannot accept further late submissions.</small></li>
  <li><small>All due dates and submission times are expressed in Pacific time.</small></li>
</ul>

<p><strong><em>You are permitted to work on this assignment in pairs.</em></strong></p>

<hr />

<p><sup><em>Parts of this assignment adapted from one by Julie Zelenski and Jerry Cain.</em></sup><br /></p>

<p>We‚Äôve spent a lot of time talking about searching, sorting, and runtime complexity. This assignment is designed to give you a sense of how to combine those ideas together in the service of something larger: diving deep into data sets. Over the course of this assignment, you‚Äôll build out a set of algorithms and data structures for processing large data sets. Once you‚Äôve gotten them working, you‚Äôll get to see them in action as they power four data analyses.</p>

<p>This assignment has three parts:</p>
<ul>
  <li><strong><em>Array Exploration</em></strong>: This debugging exercise is designed to get you comfortable exploring arrays in memory and seeing what lies beyond them.</li>
  <li><strong><em><code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code></em></strong>: This workhorse of a data structure is useful for finding the best objects of various types. It‚Äôs a powerful tool in its own right and can be used as a building block in other algorithms.</li>
  <li><strong><em>Apportionment</em></strong>: An algorithm for assigning seats in the US House of Representatives based on census results.</li>
</ul>

<p>As usual, we suggest making slow and steady progress. Here‚Äôs our recommended timetable:</p>

<ul>
  <li>Aim to complete the debugging exercise within one day of this assignment going out.</li>
  <li>Aim to complete <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> within five days of this assignment going out.</li>
  <li>Aim to start Streaming Top-k within six days of this assignment going out.</li>
</ul>

<h2 id="assignment-logistics">Assignment Logistics</h2>

<h3 id="starter-files">Starter Files</h3>

<p>We provide a ZIP of the starter project. Download the zip, extract the files, and double-click the <code class="language-c++ highlighter-rouge"><span class="p">.</span><span class="n">pro</span></code> file to open the project in Qt Creator.</p>

<blockquote>
  <p>üì¶ <a href="Assignment&#32;6.zip">Starter code</a></p>
</blockquote>

<h3 id="getting-help">Getting Help</h3>

<p>Keep an eye on the <a href="https://edstem.org/us/courses/16604/discussion/" title="Ed Discussion Forum">Ed forum</a> for an announcement of the Assignment 6 <strong>YEAH</strong> (YEAH = Your Early Assignment Help) group session where our veteran section leaders will answer your questions and share pro tips. We know it can be daunting to sit down and break the barrier of starting on a substantial programming assignment ‚Äì come to YEAH for advice and confidence to get you on your way!</p>

<p>We also here to help if you get run into issues along the way! The <a href="https://edstem.org/us/courses/16604/discussion/" title="Ed Discussion Forum">Ed forum</a> is open 24/7 for general discussion about the assignment, lecture topics, the C++ language, using Qt, and more. Always start by searching first to see if your question has already been asked and answered before making a new post.</p>

<p>To troubleshoot a problem with your specific code, your best bet is to bring it to the <a href="../../lair.html" title="LaIR helper hours">LaIR</a> helper hours or <a href="../../about_staff.html">office hours</a>.</p>

<h2 id="part-one-beyond-the-bounds-of-arrays">Part One: Beyond the Bounds of Arrays</h2>

<p>The first part of this assignment deals with pointers and dynamic allocation, and that introduces some new types of errors you‚Äôll need to learn to smoke out using the debugger. To get more familiar with what‚Äôs going on, we‚Äôre going to ask you to work the debugger to explore arrays and what you can find when you walk off the end of them.</p>

<p>Open the source file <code class="language-c++ highlighter-rouge"><span class="n">ExploreArrays</span><span class="p">.</span><span class="n">cpp</span></code>. That file contains a function named <code class="language-c++ highlighter-rouge"><span class="n">exploreArrays</span></code>. You‚Äôll trace this function in the debugger. The reason we‚Äôd like you to explore this function is that we‚Äôd like you to see what arrays look like in memory in a controlled environment before you encounter memory issues ‚Äúin the wild‚Äù (that is, when writing up your own code). It‚Äôs similar to how we wanted you to explore stack overflows in a simpler setting before turning you loose on writing your own recursive code.</p>

<div class="pset-bordered" style="background-color: white;">
<h3 id="deliverables">Deliverables</h3>

<p>Here‚Äôs what you need to do.</p>

<ol>
  <li>Set a breakpoint at the top of <code class="language-c++ highlighter-rouge"><span class="n">exploreArrays</span></code> in <code class="language-c++ highlighter-rouge"><span class="n">ExploreArrays</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
  <li>Run the program with the debugger turned on, choose the ‚ÄúExplore Arrays‚Äù option from the top menu, then click ‚ÄúGo!‚Äù to trigger the breakpoint. Follow the instructions in <code class="language-c++ highlighter-rouge"><span class="n">ExploreArrays</span><span class="p">.</span><span class="n">cpp</span></code> and write your answers in <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>.</li>
</ol>
</div>

<p><br /></p>
<hr />

<h2 id="part-two-priority-queues-and-binary-heaps">Part Two: Priority Queues and Binary Heaps</h2>

<h3 id="refresher-priority-queues">Refresher: Priority Queues</h3>

<p>As a refresher from Assignment 2, a <strong><em>priority queue</em></strong> is a modified queue in which elements are not dequeued in the order in which they were inserted. Instead, elements are removed from the queue in order of <em>priority</em>. For example, you could use a priority queue to model a hospital emergency room: patients enter in any order, but more critical patients are seen before less critical patients, regardless of how long the less-critical patients have been waiting. Similarly, if you were building a self-driving car that needed to process events, you might use a priority queue to respond to important messages (say, a pedestrian just walked in front of the car) before less important messages (say, a car switched on its turn signal).</p>

<p>For starters, here‚Äôs a refresher on the <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> type, which you first saw in Assignment 5:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">DataPoint</span> <span class="p">{</span>                                                             
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>   <span class="c1">// Name of this data point; varies by application           </span>
    <span class="kt">double</span> <span class="n">weight</span><span class="p">;</span> <span class="c1">// "Weight" of this data point. Points are sorted by weight.</span>
<span class="p">};</span>                                                                             
</code></pre></div></div>

<p>In this assignment, you'll implement your own priority queue type, <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>. Here‚Äôs the interface for the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type (we‚Äôll explain the name in a minute):</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HeapPQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">HeapPQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">HeapPQueue</span><span class="p">();</span>
    
    <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="k">const</span> <span class="n">DataPoint</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">DataPoint</span> <span class="n">dequeue</span><span class="p">();</span>
    <span class="n">DataPoint</span> <span class="n">peek</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    
    <span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    
    <span class="kt">void</span> <span class="n">printDebugInfo</span><span class="p">();</span>
    
<span class="nl">private:</span>
    <span class="cm">/* Details coming soon! */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Looking purely at the interface of this type, it sure looks like you‚Äôre dealing with a queue. You can enqueue elements, dequeue them, and peek at them. The difference between a priority queue and a regular queue is the order in which the elements are dequeued. In a regular <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code>, elements are lined up in sequential order, and calling <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span><span class="p">()</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">peek</span><span class="p">()</span></code> gives back the element added the longest time ago. In the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>, the element that‚Äôs returned by <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span><span class="p">()</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">peek</span><span class="p">()</span></code> is the element that has the <strong><em>lowest weight</em></strong>. For example, let‚Äôs imagine we set up a <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HeapPQueue</span> <span class="n">hpq</span><span class="p">;</span>                
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Amy"</span><span class="p">,</span>    <span class="mi">103</span> <span class="p">});</span>
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Ashley"</span><span class="p">,</span> <span class="mi">101</span> <span class="p">});</span>
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Anna"</span><span class="p">,</span>   <span class="mi">110</span> <span class="p">});</span>
<span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="s">"Luna"</span><span class="p">,</span>   <span class="mi">161</span> <span class="p">});</span>
</code></pre></div></div>

<p>If we write</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DataPoint</span> <span class="n">data</span> <span class="o">=</span> <span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>     
</code></pre></div></div>

<p>then the string printed out will be <code class="language-c++ highlighter-rouge"><span class="n">Ashley</span></code>, since of the four elements enqueued, the weight associated with Ashley (101) was the lowest. Calling <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span></code> again will return <code class="language-c++ highlighter-rouge"><span class="p">{</span><span class="s">"Amy"</span><span class="p">,</span> <span class="mi">103</span><span class="p">}</span></code>, since her associated weight (103) was the lowest of what remains. Calling <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span></code> a third time would return <code class="language-c++ highlighter-rouge"><span class="p">{</span><span class="s">"Anna"</span><span class="p">,</span> <span class="mi">110</span><span class="p">}</span></code>.</p>

<p>Let‚Äôs insert more values. If we call <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">enqueue</span><span class="p">({</span><span class="s">"Chioma"</span><span class="p">,</span> <span class="mi">103</span><span class="p">})</span></code> and then <code class="language-c++ highlighter-rouge"><span class="n">hpq</span><span class="p">.</span><span class="n">dequeue</span><span class="p">()</span></code>, the return value would be the newly-added <code class="language-c++ highlighter-rouge"><span class="p">{</span><span class="s">"Chioma"</span><span class="p">,</span> <span class="mi">103</span><span class="p">}</span></code> because her associated weight is lower than all others. And note that Chioma was the most-recently-added TA here; just goes to show you that this is quite different from a regular <code class="language-c++ highlighter-rouge"><span class="n">Queue</span></code>!</p>

<h3 id="background-binary-heaps">Background Binary Heaps</h3>

<p>You‚Äôll implement <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> using a data structure called a <strong><em>binary heap</em></strong>, hence the name <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>. Binary heaps are best explained by example. Below is a binary heap containing a collection of current and former TAs, each of whom is associated with a number corresponding to the class that they TAed for.</p>

<p class="text-center"><img src="img/ta_heap.png" alt="A binary heap as described. At the top lies Ashley (who TA'd for 101). There are two branches, one going left and one going right; on the left, we have Kate (106), whose left and right children are Kali (108) and Julia (109), respectively. Kali has a single left child, Luna (161). Back to the top, to Ashley's right, we have Amy (103), whose left and right children are Anna (110) and Reynis (107), respectively." /></p>

<p>Let's look at the structure of this heap. Each value in the heap is stored in a <strong><em>node</em></strong>, and each node has zero, one, or two <strong><em>child nodes</em></strong> descending from it. For example, Ashley has two children (Kate and Amy) while Kali has just one child (Luna) and Julia has no children at all.</p>

<p>In a binary heap, we enforce the rule that <strong><em>every row of the heap, except for the last, must be full</em></strong>. That is, the first row should have one node, the second row two nodes, the third row four nodes, the fourth row eight nodes, etc., up until the last row. Additionally, that last row must be filled from the left to the right. You can see this in the above example ‚Äì the first three rows are all filled in, and only the last row is partially filled. Here are two other examples of binary heaps, each of which obey this rule:</p>

<div style="display: flex; align-items: center; justify-items: center">
  <p class="m-3"><img src="img/planet_heap.png" alt="A binary heap of the names of the planets, where the radius of the planet is its priority. Mercury sits at the top, with Neptune and Mars being its children. Neptune has Jupiter and Uranus as its children. Mars has Saturn and Venus as its children. Every row of the heap is filled." /></p>

  <p class="m-3"><img src="img/name_heap.png" alt="A binary heap with various names, where the priority is their birth year. Jackie is on top, with Jermaine and Tito as their children. Jermain has Michael and Marlon as children. Tito has no children. The top two rows of the heap are full; the last one is partially filled (two of four; Jeramine has two children, while Tito has none)" /></p>
</div>

<p>We also enforce one more property ‚Äì <strong><em>no child node‚Äôs weight is less than its parent‚Äôs weight</em></strong>. All three of the heaps you've seen so far obey this rule. However, there are no guarantees about how nodes can be ordered within a row; as you can see from the examples, within a row the ordering is pretty much arbitrary.</p>

<div class="pset-bordered" style="background-color: #eeffff;">
<p>To recap, here are the three rules for binary heaps:</p>

<ul>
  <li>Every node in a binary tree has either zero, one, or two children.</li>
  <li>No child‚Äôs weight is less than the weight of its parent.</li>
  <li>Every row of the heap, except the last, is completely full, and the last row‚Äôs elements are as far to the left as possible.</li>
</ul>
</div>

<p>Before moving on, edit the file <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code> with answers to the following question.</p>

<div class="pset-bordered" style="background-color: white;">
<h4 id="concept-check-binary-heaps">Concept Check: Binary Heaps</h4>

<p><strong>Q3:</strong> Draw three different binary heaps containing the DataPoints given in the example on the right-hand side above (the one containing Jackie, Jermaine, etc.) Yes, we know that we‚Äôre asking you to draw pictures in a text file. Here‚Äôs an example of what that could look like:</p>
<pre><code class="language-plain">          Person A
           Weight
        /        \
    Person B    Person C
     Weight      Weight
    /        \
Person D    Person E
 Weight      Weight    
</code></pre>
<p>Maya Ziv, section leader extraordinaire, suggests using <a href="http://asciiflow.com/">this website</a> to draw the binary heaps.</p>
</div>

<h3 id="enqueuing-into-a-binary-heap">Enqueuing Into a Binary Heap</h3>

<p>It is easy to read off which element has the smallest weight in a binary heap ‚Äì it's the one at the top. It is also efficient to insert an element into a binary heap. Suppose, for example, that we have this binary heap containing some famous satellites:</p>

<p class="text-center"><img src="img/satellite_enqueue_1.png" alt="A binary heap showing famous satellites, with their associated priority being the year in which it was launched. The satellites are written in the language native to the country they're from. At the top is Sputnik (1957), with its left child being Aryabhata (1975) and right child being Ohsumi (1970). Aryabhata also has two children, Ofeq (1988) and Sina (2005)." /></p>

<p>Let's add the San Marco, the first Italian satellite, to this heap with weight 1964. Since a binary heap has all rows except the last filled, the only place we can initially place San Marco is in the first available spot in the last row. This is as the left child of Japan‚Äôs first space probe Â§ßÈöÖ, so we place the new node for San Marco there:</p>

<p class="text-center"><img src="img/satellite_enqueue_2.png" alt="The heap above has been modified to include San Marco (1964) as the left child of Ohsumi (1970)" /></p>

<p>At this point, the binary heap is invalid because San Marco‚Äôs weight (1964) is less than that of Â§ßÈöÖ (1970). To fix this, we run a <strong><em>bubble-up</em></strong> step and continuously swap San Marco with its parent node until its weight is at least that of its parent‚Äôs. This means that we exchange San Marco and Â§ßÈöÖ, shown here:</p>

<p class="text-center"><img src="img/satellite_enqueue_3.png" alt="The heap above has been modified to swap the positions of San Marco (1964) and Ohsumi (1970); now, the right child of Sputnik (1957) is San Marco (1964), and San Marco's left child is Ohsumi (1970)" /></p>

<p>Since San Marco‚Äôs weight (1964) is greater than its parent‚Äôs weight (1957), it‚Äôs now in the right place, and we‚Äôre done. We now have a binary heap containing all of the original values, plus San Marco.</p>

<p>Let's suppose that we now want to insert Explorer, the first US space probe, into the heap with weight 1958. We begin by placing it at the next free location in the last row, as the right child of San Marco:</p>

<p class="text-center"><img src="img/satellite_enqueue_4.png" alt="The heap above has been modified to add Explorer (1958) as the right child of San Marco." /></p>

<p>We then bubble Explorer up one level to fix the heap:</p>

<p class="text-center"><img src="img/satellite_enqueue_5.png" alt="The heap above has been modified to swap the positions of San Marco (1964) and Explorer (1958)" /></p>

<p>And, again, have a new heap containing these elements. As a final example, suppose that we want to insert ‰∏úÊñπÁ∫¢, the first Chinese space probe, into this heap with weight 1970. We begin by putting it into the first free spot in the last row, which in this case is as the left child of the Israeli satellite ◊ê◊ï◊§◊ß:</p>

<p class="text-center"><img src="img/satellite_enqueue_6.png" alt="The heap above, modified to insert Dong Fang Hong (1970) as the left child of Ofeq (1988). The heap is now four rows high (as the third row was filled by adding Explorer)." /></p>

<p>We now do a bubble-up step. We first swap ‰∏úÊñπÁ∫¢ and ◊ê◊ï◊§◊ß to get:</p>

<p class="text-center"><img src="img/satellite_enqueue_7.png" alt="The heap above has been modified to swap the positions of Dong Fang Hong (1970) and Ofeq (1988)" /></p>

<p>Notice that ‰∏úÊñπÁ∫¢‚Äôs weight is still less than its new parent‚Äôs weight, so it‚Äôs not yet in the right place. We therefore do another swap, this time with the Indian satellite ‡§Ü‡§∞‡•ç‡§Ø‡§≠‡§ü, to get</p>

<p class="text-center"><img src="img/satellite_enqueue_8.png" alt="The heap above has been modified to swap the positions of Dong Fang Hong (1970) and Aryabhata (1975)" /></p>

<p>This step runs very quickly. With a bit of math we can show that if there are n nodes in a binary heap, then the height of the heap is at most O(log n), and so we need at most O(log n) swaps to put the new element into its proper place. Thus the enqueue step runs in time O(log n). That‚Äôs pretty fast! Remember that the base-2 logarithm of a million is about twenty, so even with a million elements we‚Äôd only need about twenty swaps to place things!</p>

<p>Before moving on, answer the following question in <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>:</p>

<div class="pset-bordered" style="background-color: white;">
<h4 id="concept-check-enqueue">Concept Check: Enqueue</h4>

<p><strong>Q4:</strong> Draw the binary heap formed by inserting these nine DataPoints into an empty binary heap using the algorithm described above. Specifically, insert those data points in the order that‚Äôs shown below. You only need to show your final answer, not your intermediate steps.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="s">"R"</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"A"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"B"</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"K"</span><span class="p">,</span> <span class="mi">7</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"G"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"V"</span><span class="p">,</span> <span class="mi">9</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"T"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"O"</span><span class="p">,</span> <span class="mi">8</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"S"</span><span class="p">,</span> <span class="mi">6</span> <span class="p">}</span>
</code></pre></div></div>
<p>There are many binary heaps you can form that contain these elements, but only one of them will be what you get by tracing the algorithm.</p>
</div>

<h3 id="dequeuing-from-a-binary-heap">Dequeuing from a Binary Heap</h3>

<p>We now know how to insert an element into a binary heap. How do we implement dequeue? We know that the minimum-weight element of the binary heap is atop the heap, but we can't just remove it ‚Äì that would break the heap into two smaller heaps. Instead, we use a more clever algorithm. First, we swap the top of the heap, the original Soviet satellite –°–ø—É—Ç–Ω–∏–∫, with the rightmost node in the bottom row of the heap (◊ê◊ï◊§◊ß) as shown here:</p>

<p class="text-center"><img src="img/satellite_dequeue_1.png" alt="The same heap as before, except now Ofeq (1988) is at the root, and Sputnik (1957) is at the bottommost element of the heap (where Ofeq once was)." /></p>

<p>Now, we can remove –°–ø—É—Ç–Ω–∏–∫ from the heap, which is the element we‚Äôll return. We now have this:</p>

<p class="text-center"><img src="img/satellite_dequeue_2.png" alt="The same heap as before, but Sputnik (1957) is removed. The heap now looks like this: Ofeq (1988) at the top, with Dong Fang Hong (1970) and Explorer (1958) its left and right children. Dong Fang Hong (1970) has Aryabhata (1975) and Sina (2005) as its left and right children. Explorer (1958) has Ohsumi (1970) and San Marco (1964) as its left and right children." /></p>

<p>Unfortunately, what we are left with isn‚Äôt a binary heap because the top element (◊ê◊ï◊§◊ß) is one of the highest-weight values in the heap. To fix this, we will use a <strong><em>bubble-down</em></strong> step and repeatedly swap ◊ê◊ï◊§◊ß with its <strong><em>lower-weight</em></strong> child until it either has no children or has lower weight than all of its children. First, we swap ◊ê◊ï◊§◊ß with Explorer to get this heap:</p>

<p class="text-center"><img src="img/satellite_dequeue_3.png" alt="The same heap as before, but Explorer and Ofeq swap so Explorer is now the root of the tree." /></p>

<p>Since ◊ê◊ï◊§◊ß is not at rest yet, we swap it with the smaller of its two children (San Marco) to get this:</p>

<p class="text-center"><img src="img/satellite_dequeue_4.png" alt="The same heap as before, but San Marco and Ofeq swap." /></p>

<p>And we're done. That was fast! As with enqueue, this step runs in time O(log n), because we make at most O(log n) swaps. This means that enqueuing n elements into a binary heap and then dequeuing them takes time at most O(n log n). This method of sorting values is called <em>heapsort</em>.</p>

<p>To confirm that this makes sense, answer this question in <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>:</p>

<div class="pset-bordered" style="background-color: white;">
<h4 id="concept-check-dequeue">Concept Check: Dequeue</h4>

<p><strong>Q5:</strong> Draw the binary heap that results from following this <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> procedure on the heap you drew in Q4 of this problem.</p>
</div>

<h3 id="binary-heaps-as-arrays">Binary Heaps As Arrays</h3>

<p>How do we represent a binary heap in code? Amazingly, we can implement the binary heap using nothing more than a dynamic array. ‚ÄúAn array‚ÄΩ,‚Äù you might exclaim. ‚ÄúHow is it possible to store that complicated heap structure inside an array‚ÄΩ‚Äù The key idea is to number the nodes in the heap from top-to-bottom, left-to-right, starting at 1. For example, we might number the nodes of the previous heap like this:</p>

<p class="text-center"><img src="img/satellite_array_heap_1.png" alt="The same heap as before. Explorer is at the top labelled &quot;1&quot;. Its left and right children, Dong Fang Hong and San Marco, are labelled 2 and 3. Dong Fang Hong's children, Aryabhata and Sina, are labelled 4 and 5. San Marco's children, Ohsumi and Ofeq, are labelled 6 and 7." /></p>

<p>This numbering system has some amazing properties:</p>

<ul>
  <li>Given a node numbered n, its children (if any) are numbered 2n and 2n + 1.</li>
  <li>Given a node numbered n, its parent is numbered n / 2, rounded down.</li>
</ul>

<p>You can check this yourself in the above tree. That's pretty cool, isn't it? The reason that this works is that the heap has a rigid shape ‚Äì every row must be filled in completely before we start adding any new rows. Without this restriction, our numbering system wouldn't work.</p>

<p>Because our algorithms on binary heaps only require us to navigate from parent to child or child to parent, it's possible to represent binary heap using just an array. Each element will be stored at the index given by the above numbering system. Given an element, we can then do simple arithmetic to determine the indices of its parent or its children. For example, we‚Äôd encode the above heap as the following array:</p>

<p class="text-center"><img src="img/satellite_array_heap_2.png" alt="The same heap as before, with the above numbering system translated to an array that reads, from index 1 to 7: Explorer, Dong Fang Hong, San Marco, Aryabhata, Sina, Ohsumi, Ofeq" /></p>

<p>The enqueue and dequeue algorithms we have developed for binary heaps translate beautifully into algorithms on the array representation. For example, suppose we want to insert Ast√©rix, the first French satellite, into this binary heap with weight 1965. We begin by adding it into the heap, as shown here:</p>

<p class="text-center"><img src="img/satellite_array_enqueue_1.png" alt="The same heap as before, with Ast√©rix inserted in the bottom left (the left child of Aryabhata). The array now has eight slots, and Ast√©rix is inserted into the new eighth slot." /></p>

<p>Notice that Ast√©rix is at index 8, which is the last position in the array. This is not a coincidence; whenever you add a node to a binary heap, it always goes at the end of the array. (Do you see why?)</p>

<p>We then bubble Ast√©rix up into its final position by repeatedly comparing it to its parent. Since Ast√©rix is at position 8, its parent (‡§Ü‡§∞‡•ç‡§Ø‡§≠‡§ü) is at position 4. Since Ast√©rix precedes ‡§Ü‡§∞‡•ç‡§Ø‡§≠‡§ü, we swap them:</p>

<p class="text-center"><img src="img/satellite_array_enqueue_2.png" alt="The same heap as before, but Aryabhata and Ast√©rix have switched (Ast√©rix bubbling up to take Aryabhata's place). Similarly, in the array, Aryabhata (now at position 8) and Ast√©rix (now at position 4) swapped places." /></p>

<p>Ast√©rix‚Äôs parent is now at position 2 (‰∏úÊñπÁ∫¢), so we swap Ast√©rix and ‰∏úÊñπÁ∫¢ to get the final heap:</p>

<p class="text-center"><img src="img/satellite_array_enqueue_3.png" alt="The same heap as before, but Dong Fang Hong and Ast√©rix have switched (Ast√©rix bubbling up to take Dong Fang Hong's place). Similarly, in the array, Dong Fang Hong (now at position 4) and Ast√©rix (now at position 2) swapped places." /></p>

<p>An important detail to keep in mind when using this representation is the following. In these examples, <strong><em>the arrays are 1-indexed</em></strong>, meaning that the first slot in the array is in position 1. However, in C++, <strong><em>arrays are 0-indexed</em></strong>, which means that the first slot in the array is at position 0. There are many ways we could address this, but the option we're going to use in this assignment is the following. We'll use C++ arrays as usual, but simply ignore slot 0 in the array. So the array shown above, as encoded as a C++ array, would look like this:</p>

<p class="text-center"><img src="img/satellite_array_zero_index.png" alt="The final array representation. Slot 0 is marked &quot;unused.&quot; Slot 1 holds Explorer (1958). Slot 2 holds Asterix (1965). Slot 3 holds San Marco (1960). Slot 4 holds Dong Fang Hong (1970). Slot 5 holds Sinah (2005). Slot 6 holds Osumi (1970). Slot 7 holds Ofeq (1988). Slot 8 holds Aryabhata (1975)" /></p>

<p>And, more generally, each of the arrays shown above would have an unused slot zero before them.</p>

<p>To confirm that this all makes sense, answer the following question in ShortAnswers.txt:</p>

<div class="pset-bordered" style="background-color: white;">
<h4 id="concept-check-heaps-as-arrays">Concept Check: Heaps as Arrays</h4>

<p><strong>Q6:</strong> Draw the array representation of the binary heap that you drew in Q5. Include an unused slot 0 at the beginning of your array.</p>
</div>

<h3 id="implementing-a-binary-heap">Implementing a Binary Heap</h3>

<p>Now, let‚Äôs talk about the coding assignment. Open the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code> header file. You'll see (more or less) the following code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HeapPQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">HeapPQueue</span><span class="p">();</span>
    <span class="o">~</span><span class="n">HeapPQueue</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="k">const</span> <span class="n">DataPoint</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">DataPoint</span> <span class="n">dequeue</span><span class="p">();</span>
    <span class="n">DataPoint</span> <span class="n">peek</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">printDebugInfo</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="n">DataPoint</span><span class="o">*</span> <span class="n">elems</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">logicalSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">allocatedSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">INITIAL_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Let's explore what's in the private section here. You will be doing your own memory management in this assignment. To help with this, we've provided you with three data members for the class:</p>

<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">elems</span></code>: A pointer to a dynamically-allocated array of elements. It defaults to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>, a pointer value that means "I'm not pointing at anything."</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">logicalSize</span></code>: The number of elements currently stored in the priority queue.</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">allocatedSize</span></code>: The number of slots in the dynamically-allocated array.</li>
</ul>

<p>Your task is to implement the seven key functions in the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> interface: the constructor, destructor, <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">peek</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">isEmpty</span></code>, and <code class="language-c++ highlighter-rouge"><span class="n">size</span></code>. (You can optionally implement <code class="language-c++ highlighter-rouge"><span class="n">printDebugInfo</span></code> if you'd like to print out information helpful for debugging.) In doing so, you'll do your own memory management to make sure there's sufficient space for elements in the array pointed at by <code class="language-c++ highlighter-rouge"><span class="n">elem</span></code>s, and you'll implement the enqueue ("bubble up") and dequeue ("bubble down") operations as described above.</p>

<p>While you can in principle implement these functions in whatever order you'd like, we recommend that you code things up in the following order.</p>

<h4 id="milestone-one-implement-the-essentials">Milestone One: Implement the Essentials</h4>

<p>If you run the starter code without making changes to the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">cpp</span></code> files and select "Run Tests," you'll find that the program almost immediately crashes. That's because the tests try to read from the priority queue's <code class="language-c++ highlighter-rouge"><span class="n">elems</span></code> array, and that array is never set up to point at anything. Memory errors like these will often immediately crash the program, even in test mode. In fact, try doing this to see what it looks like! Run the program once without the debugger turned on to see what it looks like when your program crashes with a memory error. Then, do the following: without setting any breakpoints anywhere, run the program with the debugger turned on and click "Run Tests." Notice that as soon as the code crashes, the debugger kicks in and tells you the exact line where the error occured. Nifty! This is a useful tip going forward: <strong><em>if your code crashes, run it with the debugger turned on until the crash happens.</em></strong> No breakpoints needed - the debugger will engage and show you where things went wrong.</p>

<p>But of course, we'd like to make it so that things don't crash at all. üôÇ So your first milestone is to implementing the constructor to set up an initial array to work with. Your constructor should create an array whose size is given by the constant <code class="language-c++ highlighter-rouge"><span class="n">INITIAL_SIZE</span></code>. Please use this exact size - we've chosen it so that our test cases will work correctly.</p>

<p>Once you've done this, you'll see that the tests no longer crash. Most of them fail because they check the behavior of functions like <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> that you haven't implemented yet. However, one of the early tests will fail and warn about a memory leak. hat's because your constructor is allocating memory, but that memory is never freed anywhere. To address this, implement the destructor for the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type.</p>

<p>Having done this, you should see the first few tests pass and everything else fail. And that's fine - you haven't actually implemented the basic <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> operations yet, and having the test fail is a marked step up from the test cases crashing!</p>

<p>And finally, once you've done that, implement the <code class="language-c++ highlighter-rouge"><span class="n">size</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">isEmpty</span></code> functions.</p>

<p>To summarize, here's what you need to do.</p>

<div class="pset-bordered" style="background-color: white;">
<ol>
  <li>
    <p><em>(Optional)</em> Run the starter files using the "Run" button without adding or changing anything. Click "Run Tests" to see what a crash looks like. Then, run the starter files again with the debugger engaged - without adding any breakpoints - and click "Run Tests" a second time. This will trigger the debugger at the crash site, and you can then backtrace to see where the crash was.</p>
  </li>
  <li>
    <p>Implement the constructor for <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>.</p>
  </li>
  <li>
    <p>Implement the destructor for <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>.</p>
  </li>
  <li>
    <p>Implement the <code class="language-c++ highlighter-rouge"><span class="n">size</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">isEmpty</span></code> functions on <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>.</p>
  </li>
  <li>
    <p>Confirm that the first few tests, which just focus on these functions, are passing.</p>
  </li>
</ol>

</div>

<h4 id="milestone-two-implement-enqueue">Milestone Two: Implement <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code></h4>

<p>It's now time to implement the <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> function. There are two separate components to this function. First, you'll need to faithfully implement the "bubble up" logic as described above in the section above. Second, you'll need to manage the memory in your underlying array so that if you run out of space, you grow the underlying array.</p>

<p>Because these are two separate steps, we recommend that you do this in two separate steps. First, get the basic enqueue logic working, without making any effort to resize the array if you need more space. To prevent your code from crashing, we recommend that, at the top of your function, you add a check that detects whether you've run out of space for more elements and reports an <code class="language-c++ highlighter-rouge"><span class="n">error</span></code> if so, like what we did with our initial bounded stack implementation. This will let you run the tests that purely look for the core logic in enqueue.</p>

<p>Once those tests are passing and you're confident that your basic <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> logic works, add in the necessary logic to resize and grow the array. As in lecture, whenever you run out of space, double the size of the underlying array and copy elements from the old array to the new one.</p>

<p>To summarize:</p>

<div class="pset-bordered" style="background-color: white;">
<ol>
  <li>
    <p>Implement the <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> function on <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>. Our recommendation is to first have this function report an <code class="language-c++ highlighter-rouge"><span class="n">error</span></code> if there's no space left in the array so you can focus on getting the bubble-up logic right. Then remove the call to <code class="language-c++ highlighter-rouge"><span class="n">error</span></code> and instead grow the array if you're out of space.</p>
  </li>
  <li>
    <p>Confirm that tests for the <code class="language-c++ highlighter-rouge"><span class="n">enqueue</span></code> function work correctly.</p>
  </li>
</ol>
</div>

<p>Some notes on this part:</p>

<ul>
  <li>
    <p><strong><em>If your program mysteriously stops running without warning, it probably crashed.</em></strong> To see where it crashes, <strong><em>run the program in debug mode</em></strong>. You don‚Äôt need to set any breakpoints ‚Äì simply running in debug mode will let the debugger catch where your program crashed. It‚Äôll stop the program at that point as if you‚Äôd set a breakpoint there, and you can then walk up and down the call stack, look at local variables, etc. to see what‚Äôs going on. Common causes of program crashes this way include the following:</p>

    <ul>
      <li>
        <p>Writing to an array variable through an uninitialized pointer. If you don‚Äôt initialize a pointer, it‚Äôs not given a sensible default value. It might be a null pointer, and writing to a null pointer will cause a crash. It might be a pointer to memory you don‚Äôt own, which will crash your program. Or it might point to memory you do own, in which case you might see a crash or might not, depending on whether you were (un)lucky.</p>
      </li>
      <li>
        <p>Writing to an array variable pointing at deallocated memory. Once you‚Äôve used delete[] to deallocate an array, you should not try reading or writing that memory. (That would be like trying to let yourself into a building you just sold to someone else.)</p>
      </li>
      <li>
        <p>Writing past the end of an array. You saw this in the warmup assignment.</p>
      </li>
      <li>
        <p>Writing before the start of an array. This can happen if your indices are wrong.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><em>The indices in our array-based heap start at one.</em></strong> C++ arrays are zero-indexed but binary heaps are 1-indexed, so slot 0 in the <code class="language-c++ highlighter-rouge"><span class="n">elems</span></code> array should never be read from or written to. Stated differently, your code should never touch the value in <code class="language-c++ highlighter-rouge"><span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code>. Many bugs in this part of the assignment arise from accidentally putting an element there or comparing the weight of one <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> against the weight of the (uninitialized) <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> in slot 0.</p>
  </li>
  <li>
    <p><strong><em>Draw lots of pictures.</em></strong> Debugging the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> is largely an exercise in determining where your code does something that diverges from what you expect to happen. If your code isn't working correctly, step through it using the debugger, drawing pictures of what you see and comparing them against pictures of what you think should happen.</p>
  </li>
  <li>
    <p>You saw how to use the debugger to view an array of <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code>s in Part One of this assignment. That skill might come in handy here.</p>
  </li>
  <li>
    <p>You are welcome to define private helper functions in <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code>. However, please do not change the signatures of any of the functions that we have provided to you, and do not change the names or types of any of the private data members we gave to you in the starter file.</p>
  </li>
  <li>
    <p>Bubbling up requires swapping elements in the array. We recommend using the <code class="language-c++ highlighter-rouge"><span class="n">swap</span></code> function from the <code class="language-c++ highlighter-rouge"><span class="o">&lt;</span><span class="n">algorithm</span><span class="o">&gt;</span></code> header for this. It takes in two arguments and swaps their values.</p>
  </li>
  <li>
    <p>If multiple data points are tied for the same weight, you can break those ties however you‚Äôd like.</p>
  </li>
  <li>
    <p>Our testing harness automatically checks for memory leaks and other types of memory errors. If you allocate memory without later deallocating it, the test driver will tell you how many objects you leaked. You will then need to explore your code to find the source of the memory error.</p>
  </li>
  <li>
    <p>The C++ standard libraries contain a function <code class="language-c++ highlighter-rouge"><span class="n">std</span><span class="o">::</span><span class="n">push_heap</span></code> that implements the bubble-up algorithm. For the purposes of this assignment, please refrain from using those functions.</p>
  </li>
</ul>

<h4 id="milestone-three-implement-peek-and-dequeue">Milestone Three: Implement <code class="language-c++ highlighter-rouge"><span class="n">peek</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code></h4>

<p>Implement the <code class="language-c++ highlighter-rouge"><span class="n">peek</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> functions. The <code class="language-c++ highlighter-rouge"><span class="n">peek</span></code> function should return the element of the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> with the lowest weight, and should call the <code class="language-c++ highlighter-rouge"><span class="n">error</span></code> function to report an error if the priority queue is empty.</p>

<p>Your <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> function should remove and return the <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> in the priority queue with the lowest weight, calling <code class="language-c++ highlighter-rouge"><span class="n">error</span></code> if the priority queue is empty. You should use the "bubble-down" strategy outlined above. Because your binary heap elements are stored in an array, you'll need to do some arithmancy to figure out where an element's children are. This is a great spot to draw pictures of different binary heaps represented both as a tree and as an array. Once you've gotten this working, all the provided tests should pass!</p>

<p>To recap:</p>

<div class="pset-bordered" style="background-color: white;">
<ol>
  <li>
    <p>Implement the <code class="language-c++ highlighter-rouge"><span class="n">peek</span></code> function on <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>.</p>
  </li>
  <li>
    <p>Implement the <code class="language-c++ highlighter-rouge"><span class="n">dequeue</span></code> function on <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>.</p>
  </li>
  <li>
    <p>Confirm that all the provided tests pass.</p>
  </li>
</ol>
</div>

<p>Some notes on this problem:</p>

<ul>
  <li>
    <p>Much of the same advice from above applies here - draw lots of pictures, run the program in debug mode if it crashes or if a test fails, etc.</p>
  </li>
  <li>
    <p>As you're coding this one up, make sure not to read off past the end of the array. It's very easy to do this accidentally if you have a math error in your bounds-checking code or logic for determining where an element's children are. This can manifest in many different ways. You might see the code immediately crash, or you might just get back garbage values that don't correspond to array elements. Regardless of the source, if this happens, run the code with the debugger engaged to see if you can spot where the error occurs.</p>
  </li>
  <li>
    <p>Because C++ arrays have a fixed size that's set when the array is created, your array of elements will likely have more slots in it than there are elements in the priority queue. As a result, it's important to not try reading from array indices that don't correspond to elements in the binary heap. If you read array slots that don't have elements in them, it won't crash your program, and instead you'll see uninitialized <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> values. A common symptom that you've read these elements is that the tests will fail and report strange <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code>s whose associated <code class="language-c++ highlighter-rouge"><span class="n">weights</span></code> are bizarre values.</p>
  </li>
  <li>
    <p>Remember that, during the bubble-down step, an element may have 0 children, 1 child, or 2 children. You'll need to ensure your code works in each of those cases.</p>
  </li>
</ul>

<h4 id="milestone-four-final-tests">Milestone Four: Final Tests</h4>

<p>Finally, validate that your implemention runs efficiently. If you insert <em>n</em> elements into an empty binary heap and then remove all <em>n</em> of them, the runtime should be O(<em>n</em> log <em>n</em>). Our provided "Time Test" menu option will you run this exact workflow on your <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type and give you a runtime plot you can use to size up whether this workflow indeed runs as quickly as intended.</p>

<p>You'll also need to write at least one custom test for your <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>. There are lot of cases not covered by the existing tests. Adding in additional test support will help increase your confidence that your code works correctly.</p>

<p>To summarize:</p>

<div class="pset-bordered" style="background-color: white;">
<ol>
  <li>
    <p>Select the "Time Tests" option from the main menu and click the "<code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>" button to get performance data on enqueuing <em>n</em> items into your <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>, then dequeuing them all.</p>
  </li>
  <li>
    <p>Confirm the data support a runtime of O(<em>n</em> log <em>n</em>). If not, investigate your code and see if you can locate the source of the inefficiency.</p>
  </li>
  <li>
    <p>Write at least one <code class="language-c++ highlighter-rouge"><span class="n">STUDENT_TEST</span></code> in <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">cpp</span></code>. Before doing so, read over the existing tests to see what they do and don't cover, and aim to patch a hole in the test coverage.</p>
  </li>
</ol>
</div>

<p><br /></p>
<hr />

<h2 id="part-three-apportionment">Part Three: Apportionment</h2>

<h3 id="background-the-huntington-hill-method">Background: The Huntington-Hill Method</h3>

<p><strong><em>(This part of the assignment requires you to have <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> working, so we recommend doing it last.)</em></strong></p>

<p>Every decade, the United States conducts a census to ‚Äú<a href="https://www.census.gov/programs-surveys/decennial-census/decade/2020/2020-census-main.html">count every person living in the United States and the five U.S. territories</a>.‚Äù These numbers are then used to determine how many seats in the House of Representatives will be allocated to each state. That process ‚Äì going from state populations to numbers of seats ‚Äì is called <strong><em>apportionment</em></strong>.</p>

<p>Apportioning seats fairly is trickier than it looks, and in fact the exact mechanism for doing this was hotly debated for much of US history. Eventually, in 1941, Congress settled on an algorithm called the <strong><em>Huntington-Hill method</em></strong>, and that algorithm has been used ever since.</p>

<p>The Huntington-Hill algorithm works as follows. Initially, give each state one house seat. Then, drop all of the states into a <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>. The weight associated with each state is given by its population, divided by $\sqrt{2}$ (more on that later). Finally, repeat the following process to assign a single seat until all seats are allocated to the states.</p>

<ul>
  <li>
    <p>Remove the highest-weight state from the priority queue.</p>
  </li>
  <li>
    <p>Give that state another House seat.</p>
  </li>
  <li>
    <p>Reinsert that state into the priority queue with weight equal to $\frac{P}{\sqrt{S(S+1))}}$, where $P$ is the state‚Äôs population and $S$ is the number of seats currently assigned to the state, including the one just awarded.</p>
  </li>
</ul>

<p>For example, let‚Äôs suppose that we have five states: the State of Mind, the State of Denial, the State of Affairs, the State of Being, and the State of Matter. Their populations are as shown here. For consistency, I've listed these states in alphabetical order:</p>

<ul>
  <li>Affairs: 7,984</li>
  <li>Being: 14,938</li>
  <li>Denial: 13,509</li>
  <li>Matter: 14,617</li>
  <li>Mind: 25,419</li>
</ul>

<p>Further, let‚Äôs suppose that there are 14 house seats to allocate. We begin by giving each state one seat, then adding each state into a HeapPQueue with priority equal to their population divided $\sqrt{2}$. Here are the values now stored in the priority queue. For simplicity, I‚Äôve shown them in the same order they‚Äôre listed above rather than in the order they‚Äôd be stored in in the priority queue. (These values are rounded to two decimal places.)</p>

<ul>
  <li>Affairs: 5,645.54</li>
  <li>Being: 10,562.76</li>
  <li>Denial: 9,552.31</li>
  <li>Matter: 10,335.95</li>
  <li>Mind: 17,973.95</li>
</ul>

<p>We now pick the state with the <strong><em>highest</em></strong> weight and assign it another seat. Here, that means that the State of Mind gets another seat. We compute its new weight using the formula from above. The State of Mind has a population of 25,419 and it currently has two seats assigned (the initial one from above, plus the one we just gave it), so we compute its new weight as $\frac{25,419}{\sqrt{2 \cdot (2 + 1)}} \approx 10,377.26$ and add that back to the priority queue. Here‚Äôs the priorities now associated with the five states (again, in their original order, not sorted by weight):</p>

<ul>
  <li>Affairs: 5,645.54</li>
  <li>Being: 10,562.76</li>
  <li>Denial: 9,552.31</li>
  <li>Matter: 10,335.95</li>
  <li>Mind: 10,377.26</li>
</ul>

<p>The highest-weight state (State of Being) gets the next seat. We add it back to the priority queue, using the formula from above to compute its priority as $\frac{14,938}{\sqrt{2 \cdot (2 + 1)}} \approx 6,098.41$. Our ordering now looks like this:</p>

<ul>
  <li>Affairs: 5,645.54</li>
  <li>Being: 6,098.41</li>
  <li>Denial: 9,552.31</li>
  <li>Matter: 10,335.95</li>
  <li>Mind: 10,377.26</li>
</ul>

<p>Next up is the State of Mind, which now gets a third seat. We compute its new weight using the formula from above, giving it a new weight of $\frac{25,419}{\sqrt{3 \cdot (3 + 1)}} \approx 7,337.83$. That‚Äôs shown here:</p>

<ul>
  <li>Affairs: 5,645.54</li>
  <li>Being: 6,098.41</li>
  <li>Denial: 9,552.31</li>
  <li>Matter: 10,335.95</li>
  <li>Mind: 7,337.83</li>
</ul>

<p>If you carry on this process, the next seats will go to Matter, then Denial, then Mind, then Being, then Matter again, then Mind again. The final apportionment is then that</p>

<ul>
  <li>Affairs gets 1 seat,</li>
  <li>Being gets 3 seats,</li>
  <li>Denial gets 2 seats,</li>
  <li>Matter gets 3 seats, and</li>
  <li>Mind gets 5 seats.</li>
</ul>

<h3 id="milestone-one-implement-apportionment">Milestone One: Implement Apportionment</h3>

<p>Your task is to implement a function</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">apportion</span><span class="p">(</span><span class="k">const</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">populations</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numSeats</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input a map from states to populations, along with a number of seats, then returns the apportionment given by the Huntington-Hill algorithm.</p>

<p>One of the key steps you‚Äôll need to figure out to solve this problem is the following. The <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type is excellent at finding the entry with the <em>lowest</em> weight. However, for the Huntington-Hill algorithm, you need to find the entry with the <em>highest</em> weight. For the purposes of this problem, <strong><em>you must not make any changes to your <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type</em></strong>, and instead should just use the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> as-is. See if you can find a clever way to ‚Äútrick‚Äù the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> into handing back the highest-weight item at each step rather than the lowest-weight item.</p>

<p>Here‚Äôs what you need to do for this part of the assignment:</p>

<div class="pset-bordered" style="background-color: white;">
<p>Coding Requirements</p>

<ol>
  <li>
    <p>Implement the the <code class="language-c++ highlighter-rouge"><span class="n">apportion</span></code> function in <code class="language-c++ highlighter-rouge"><span class="n">Apportionment</span><span class="p">.</span><span class="n">cpp</span></code>. You will need to use the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type that you built in the previous part of this assignment in the course of doing this. However, you should <strong><em>not</em></strong> modify the files <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">cpp</span></code> to solve this problem (unless, of course, you‚Äôre fixing bugs in the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type).</p>
  </li>
  <li>
    <p>Add at least one custom test case ‚Äì and, ideally, many more ‚Äì and test your code thoroughly using the test suite.</p>
  </li>
</ol>

</div>

<p>Some notes on this problem:</p>

<ul>
  <li>
    <p>The Huntington-Hill method assumes that there are at least as many seats as there are states. If there are more states than seats, you should call <code class="language-c++ highlighter-rouge"><span class="n">error</span><span class="p">()</span></code> to report an error.</p>
  </li>
  <li>
    <p>Remember that the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code>‚Äôs dequeue function removes and returns the <em>lowest-weight</em> item. However, the Huntington-Hill algorithm works by taking out the <em>highest-weight</em> item at each step. We‚Äôll leave it to you to determine how to handle this.</p>
  </li>
  <li>
    <p>Use the <code class="language-c++ highlighter-rouge"><span class="n">sqrt</span></code> function from the header <code class="language-c++ highlighter-rouge"><span class="o">&lt;</span><span class="n">cmath</span><span class="o">&gt;</span></code> to compute square roots. Remember that C++ doesn‚Äôt have a <code class="language-c++ highlighter-rouge"><span class="o">**</span></code> operator to compute powers, and that the <code class="language-c++ highlighter-rouge"><span class="o">^</span></code> operator means something totally different than exponentiation.</p>
  </li>
  <li>
    <p>Don‚Äôt worry about what happens if at some point in the process two states are tied with the same weight. If that happens, break ties arbitrarily. (In practice, you wouldn‚Äôt actually do this, but it‚Äôs a fair simplification for our model.)</p>
  </li>
  <li>
    <p>The Huntington-Hill algorithm, as we‚Äôve outlined it, takes time O(<em>n</em> log <em>k</em>), where <em>n</em> is the number of seats and <em>k</em> is the number of states. (Great question to ponder: why?) Your implementation should meet this time bound. Assuming you more or less follow what we‚Äôve outlined, your approach should take this much time.</p>
  </li>
</ul>

<h3 id="milestone-two-explore-and-evaluate">Milestone Two: Explore and Evaluate</h3>

<p>After the 2020 US Census, several news outlets reported the following claim: if 89 more people were living in New York, or 26 fewer people were living in Minnesota, then New York would have ended up with one more house seat and Minnesonta would end up with one fewer. We‚Äôve provided you the 2020 US Census population totals that were used in the 2020 apportionment. You now have a tool you can use to explore how seats in the House of Representatives are allocated. So ‚Äì are those claims true?</p>

<div class="pset-bordered" style="background-color: white;">
<p>Use the provided demo to load the 2020 census numbers used in to determine apportionment (<code class="language-c++ highlighter-rouge"><span class="mf">2020.</span><span class="n">csv</span></code>), and see how many seats New York and Minnesota each received. Then compare that against the files <code class="language-c++ highlighter-rouge"><span class="mi">2020</span><span class="o">-</span><span class="n">NYUp89</span><span class="p">.</span><span class="n">csv</span></code> and <code class="language-c++ highlighter-rouge"><span class="mi">2020</span><span class="o">-</span><span class="n">MNDown26</span><span class="p">.</span><span class="n">csv</span></code>, which represent adding 89 people to New York or removing 26 from Minnesota, respectively, and see what happens. Then, answer the following questions in the file <code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code>:</p>

<p><strong>Q7</strong>: Is it true that 89 more people in New York would give New York another house seat?</p>

<p><strong>Q8</strong>: Is it true that 26 fewer people in Minnesota would give New York another house seat?</p>
</div>

<p>Censuses, like elections, are a big deal. Please keep this in mind if you‚Äôre living in the US in 2030!</p>

<p><br /></p>
<hr />

<h2 id="optional-part-four-extensions">(Optional) Part Four: Extensions</h2>

<p>There are many, many ways you could do extensions on this assignment. Here are a few:</p>

<ul>
  <li>
    <p><strong><em>Priority Queue</em></strong>: There are so many different ways to implement priority queues, of which the binary heap is only one. Other heaps like the <em>Leonardo heap</em> and <em>poplar heap</em> store elements in a collection of small trees that in turn are encoded as a single array. Research one of these data structures and code up your own implementation.</p>

    <p>Using some clever algorithms, you can construct a binary heap from $n$ items in time $O(n)$ using an algorithm called <strong><em>heapify</em></strong>. Research the heapify algorithm, then code it up.</p>
  </li>
  <li>
    <p><strong><em>Apportionment</em></strong>: You now have a tool you can use to explore the representational ramifications for various proposals that have been made over the years. Pick some proposal (for example, changing the number of seats in the House of Representatives, admitting Puerto Rico as a state, etc.) and evaluate what effect it would have on representation.</p>

    <p>The Huntington-Hill method is one of many methods for apportionment. Historically, the US used several other methods, and in countries with party-list proportional representation a variety of similar methods are used to allocate seats. Research these methods, the tradeoffs involved, and the significance of the Balinski-Young Theorem, and report what you find. We recommend running some experiments of your own to quantitatively discuss their differences and tradeoffs.</p>

    <p>We've looked at the Huntington-Hill method here because it's the one used in the US and we recently had a census. However, representative governments around the world face similar issues of determining how many seats to give to different representatives. Apply your algorithm to interesting data sets from aronud the world and let us know what you find!</p>
  </li>
</ul>

<h2 id="submission-instructions">Submission Instructions</h2>
<p>Before you call it done, run through our <a href="../../resources/submit_checklist.html" title="Submit checklist">submit checklist</a> to be sure all your <code class="language-c++ highlighter-rouge"><span class="n">t</span></code>s are crossed and <code class="language-c++ highlighter-rouge"><span class="n">i</span></code>s are dotted. Make sure your code follows our <a href="../../resources/style_guide.html" title="Style Guide">style guide</a>. Then upload your completed files to Paperless for grading.</p>

<p><strong>Partner Submissions:</strong></p>
<ul>
  <li>If you forget to list your partner you can resubmit to add one</li>
  <li>Either person can list the other, and the submissions (both past and future) will be combined</li>
  <li>Partners are listed per-assignment</li>
  <li>You can't change/remove a partner on an individual submission</li>
</ul>

<p>Please submit only the files you edited; for this assignment, these files will be:</p>

<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">ShortAnswers</span><span class="p">.</span><span class="n">txt</span></code></li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">cpp</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span><span class="p">.</span><span class="n">h</span></code>. <em>(Don‚Äôt forget the header file!)</em></li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">Apportionment</span><span class="p">.</span><span class="n">cpp</span></code>.</li>
</ul>

<p>You don't need to submit any of the other files in the project folder.</p>

<blockquote>
  <p>üèÅ <a href="https://cs198.stanford.edu/paperless" title="Go to Paperless site">Submit to Paperless</a></p>
</blockquote>

<p>If you modified any other files that you modified in the course of coding up your solutions, submit those as well. And that‚Äôs it! You‚Äôre done!</p>

<blockquote>
  <p><strong><em>Good luck, and have fun!</em></strong></p>
</blockquote>
</div>
        <div class="col-xs-hidden col-md-2"><nav class="fixed-top-right toc" id="toc"></nav></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

    <script>
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '#toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '#content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h2, h3, h4',
      });
    </script>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials ¬© Stanford University 2021 </br>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2022-Mar-02
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
