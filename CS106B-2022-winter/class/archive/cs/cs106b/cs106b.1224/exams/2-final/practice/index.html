<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="../../../_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B Final Exam Practice Problems</title>
    
    
    <!-- MathJax -->
    <script>
        window.MathJax = {
            loader: {
                load: ['[tex]/cancel', '[tex]/braket']
            },
            tex: {
                inlineMath: [
                    ['$', '$']
                ],
                packages: {
                    '[+]': ['cancel', 'braket', 'marvosym']
                },
                macros: {
                    blank:    "{\\underline{\\phantom{\\_\\_\\_\\_\\_}}}",
                    floor:    ["{\\left\\lfloor {#1} \\right\\rfloor}", 1],
                    ceil:     [ "{\\left\\lceil {#1} \\right\\rceil}", 1],
                    abs:      [ "{\\left\\vert {#1} \\right\\vert}", 1],
                    powerset: [ "{\\wp\\left( {#1} \\right)}", 1],
                    suchthat: "{\\ \\vert \\ }",
                    cfgor:    "{\\ \\vert \\ }",
                    naturals: "{\\mathbb{N}}",
                    integers: "{\\mathbb{Z}}",
                    reals:    "{\\mathbb{R}}",
                    qed:      "{\\blacksquare}",
                    phibar:   "{\\overline{\\varphi}}",
                    accepts:  "{\\text{ accepts }}",
                    rejects:  "{\\text{ rejects }}",
                    loopson:  "{\\text{ loops on }}",
                    haltson:  "{\\text{ halts on }}",
                    encoded:  [ "{\\left\\langle {#1} \\right\\rangle}", 1],
                    rlangs:   "\\mathbf{R}",
                    relangs:  "\\mathbf{RE}",
                    corelangs:"\\text{co-}\\mathbf{RE}",
                    plangs:   "\\mathbf{P}",
                    nplangs:  "\\mathbf{NP}"
                }
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
    <nav class="navbar navbar-expand-md navbar-dark" role="navigation">
  <a class="navbar-brand" href="../../../index.html">üè†CS106B </a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="navbar-collapse collapse"  id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Course Admin </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../../syllabus.html">Syllabus</a>
            
            
            
              <a class="dropdown-item" href="../../../course_placement.html">Course Placement Guide</a>
            
            
            
              <a class="dropdown-item" href="../../../honor_code.html">Honor Code</a>
            
            
            
              <a class="dropdown-item" href="../../../about_staff.html">Teaching Team</a>
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Resources </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../../lair.html">LaIR</a>
            
            
            
              <a class="dropdown-item" href="../../../about_partners.html">Guide to Partners</a>
            
            
            
              <a class="dropdown-item" href="https://edstem.org/us/courses/16604/discussion/">Ed Discussion Forum</a>
            
            
            
              <a class="dropdown-item" href="https://cs198.stanford.edu/paperless">Paperless</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/dept/cs_edu/resources/qt/">Qt Installation Guide</a>
            
            
            
              <a class="dropdown-item" href="http://en.cppreference.com/">C++ Reference</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/">Stanford Library Documentation</a>
            
            
            
              <a class="dropdown-item" href="https://docs.google.com/document/d/12cXSV84N9lhU-4tsdEmNJRlSBcwwDpsaAePWP15RUjU/">String Reference Guide</a>
            
            
            
              <a class="dropdown-item" href="../../../resources/style_guide.html">Style Guide</a>
            
            
            
              <a class="dropdown-item" href="../../../resources/testing_guide.html">Testing Guide</a>
            
            
            
              <a class="dropdown-item" href="../../../resources/debugging_guide.html">Debugging Guide</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1224/resources/bigo_guide.html">Guide to Big-O Notation</a>
            
            
            
              <a class="dropdown-item" href="../../../resources/python_to_cpp.html">Python to C++ Guide</a>
            
            
            
              <a class="dropdown-item" href="../../../resources/submit_checklist.html">Submission Checklist</a>
            
            
            
              <a class="dropdown-item" href="https://web.stanford.edu/dept/cs_edu/resources/textbook/">Textbook</a>
            
            
            
              <a class="dropdown-item" href="../../../how_to_improve.html">How to Improve</a>
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Lectures </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../../about_lectures.html">About Lectures</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../../lectures/00-welcome/index.html">  0.  1/3 Introduction </a>
                
                  <a class="dropdown-item" href="../../../lectures/01-functions/index.html">  1.  1/5 Functions in C++ </a>
                
                  <a class="dropdown-item" href="../../../lectures/02-strings/index.html">  2.  1/7 Strings in C++ </a>
                
                  <a class="dropdown-item" href="../../../lectures/03-collections-1/index.html">  3.  1/10 Containers, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/04-collections-2/index.html">  4.  1/12 Containers, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/05-collections-3/index.html">  5.  1/14 Containers, Part III </a>
                
                  <a class="dropdown-item" href="../../../lectures/06-recursion-1/index.html">  6.  1/19 Thinking Recursively, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/07-recursion-2/index.html">  7.  1/21 Thinking Recursively, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/08-recursion-3/index.html">  8.  1/24 Thinking Recursively, Part III </a>
                
                  <a class="dropdown-item" href="../../../lectures/09-recursion-4/index.html">  9.  1/26 Thinking Recursively, Part IV </a>
                
                  <a class="dropdown-item" href="../../../lectures/10-recursion-5/index.html">  10.  1/28 Thinking Recursively, Part V </a>
                
                  <a class="dropdown-item" href="../../../lectures/11-big-o/index.html">  11.  1/31 Big-O Notation </a>
                
                  <a class="dropdown-item" href="../../../lectures/12-searching-sorting-1/index.html">  12.  2/2 Searching and Sorting, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/13-searching-sorting-2/index.html">  13.  2/4 Searching and Sorting, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/14-designing-abstractions/index.html">  14.  2/7 Designing Abstractions </a>
                
                  <a class="dropdown-item" href="../../../lectures/15-implementing-abstractions-1/index.html">  15.  2/9 Implementing Abstractions, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/16-implementing-abstractions-2/index.html">  16.  2/11 Implementing Abstractions, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/17-hashing-1/index.html">  17.  2/14 Hashing, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/18-ethics/index.html">  18.  2/16 Applied Ethics </a>
                
                  <a class="dropdown-item" href="../../../lectures/19-hashing-2/index.html">  19.  2/18 Hashing, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/20-linked-lists-1/index.html">  20.  2/23 Linked Lists, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/21-linked-lists-2/index.html">  21.  2/25 Linked Lists, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/22-bsts-1/index.html">  22.  2/28 Binary Search Trees, Part I </a>
                
                  <a class="dropdown-item" href="../../../lectures/23-bsts-2/index.html">  23.  3/2 Binary Search Trees, Part II </a>
                
                  <a class="dropdown-item" href="../../../lectures/24-beyond-data-structures/index.html">  24.  3/4 Beyond Data Structures </a>
                
                  <a class="dropdown-item" href="../../../lectures/25-graphs.html">  25.  3/7 Graphs </a>
                
                  <a class="dropdown-item" href="../../../lectures/26-msts.html">  26.  3/9 Minimum Spanning Trees </a>
                
                  <a class="dropdown-item" href="../../../lectures/27-where-to-go-from-here/index.html">  27.  3/11 Where to Go From Here </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Assignments </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../../about_assignments.html">About Assignments</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../../assignments/a0/index.html">  0.   Welcome to CS106B! </a>
                
                  <a class="dropdown-item" href="../../../assignments/a1/index.html">  1.   Welcome to C++! </a>
                
                  <a class="dropdown-item" href="../../../assignments/a2/index.html">  2.   Fun with Collections </a>
                
                  <a class="dropdown-item" href="../../../assignments/a3/index.html">  3.   Recursion! </a>
                
                  <a class="dropdown-item" href="../../../assignments/a4/index.html">  4.   Recursion to the Rescue! </a>
                
                  <a class="dropdown-item" href="../../../assignments/a5/index.html">  5.   Bag'O Big-O </a>
                
                  <a class="dropdown-item" href="../../../assignments/a6/index.html">  6.   Data Sagas </a>
                
                  <a class="dropdown-item" href="../../../assignments/a7/index.html">  7.   The Great Stanford Hash-Off </a>
                
                  <a class="dropdown-item" href="../../../assignments/a8/index.html">  8.   The Adventures of Links </a>
                
                  <a class="dropdown-item" href="../../../assignments/a9/index.html">  9.   Huffman Coding </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Sections </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../../about_section.html">About Sections</a>
            
            
            
              <a class="dropdown-item" href="https://cs198.stanford.edu/cs198/auth/default.aspx">Section Portal</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../../section/section1/index.html">  1.   C++ fundamentals </a>
                
                  <a class="dropdown-item" href="../../../section/section2/index.html">  2.   Containers </a>
                
                  <a class="dropdown-item" href="../../../section/section3/index.html">  3.   Recursion Etudes </a>
                
                  <a class="dropdown-item" href="../../../section/section4/index.html">  4.   Recursive Backtracking </a>
                
                  <a class="dropdown-item" href="../../../section/section5/index.html">  5.   Class Design and Dynamic Memory Allocation </a>
                
                  <a class="dropdown-item" href="../../../section/section6/index.html">  6.   Class Design and Hashing </a>
                
                  <a class="dropdown-item" href="../../../section/section7/index.html">  7.   Linked Lists </a>
                
                  <a class="dropdown-item" href="../../../section/section8/index.html">  8.   Trees </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdown" role="button" data-toggle="dropdown" href="index.html#"aria-haspopup="true" aria-expanded="false"> Exams </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
            
            
              <a class="dropdown-item" href="../../../midterm_logistics.html">Midterm Logistics</a>
            
            
             <div class="dropdown-divider"></div>
            
            
             
                
                  <a class="dropdown-item" href="../../1-midterm/index.html">  1.   Midterm Exam </a>
                
                  <a class="dropdown-item" href="../index.html">  2.   Final Exam </a>
                
            
            
          </div>
          </li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../../schedule.html">üóìSchedule</a></li>
        
      
    </ul>
    <!---
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" id="search-text" name="query" placeholder="üîç Search CS106B..." aria-label="Search" action="search">
    </form>
    --->
  </div>
</nav>

<style>
  .navbar {
    margin-bottom: 2rem;
  }
  .navbar-dark {
    background-color: #444;
  }
 .nav-item > a {
    text-transform: uppercase;
    letter-spacing: .08rem;
    font-size: small;
    color: #bbb !important;
  }
  .nav-item > a:hover {
    color: white !important;
  }
</style>
    <div class="alert alert-warning text-center mx-auto p-2">
    <big>‚ö†Ô∏è This page is not current. It is an archive from Winter Quarter 2022.</big>
</div>

    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">Final Exam Practice Problems</h1>

<hr>

<p class="attribution">

</p>


    <div class="row">
        <div class="col-xs-12 col-md-10" id="content"<>
<p>Here's a sampler of practice problems you can use to prepare for the final exam. This collection of problems is drawn from past CS106B final exams given over the years. It's not meant to be a representative sample of the <em>length</em> of the final exam - this collection of problems is far bigger than any exam I've ever given in any class - but rather to give you a sense of what sorts of questions you might expect to see.</p>

<h2 id="problem-one-data-structure-sleuthing">Problem One: Data Structure Sleuthing</h2>

<p>On Assignment 5, you gained experience writing code that met specific runtime bounds. On Assignments 6 and 7, you saw how to implement a number of common container types. This question is designed to let you demonstrate what you‚Äôve learned about algorithmic analysis and data structure design.</p>

<p>Below are four functions. We picked one of those functions and ran it on many different values of n. We captured the output of that function on each of those inputs, along with the runtime. That information is printed in the table below.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">function1</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">values</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">values</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">function2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">values</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">values</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="n">dequeue</span><span class="p">();</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">function3</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">values</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">:</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">result</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">function4</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">values</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">values</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">values</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<table class="table">
  <thead>
    <tr>
      <th>n</th>
      <th>Time</th>
      <th>Return Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100,000</td>
      <td>0.137s</td>
      <td>99999</td>
    </tr>
    <tr>
      <td>200,000</td>
      <td>0.274s</td>
      <td>199999</td>
    </tr>
    <tr>
      <td>300,000</td>
      <td>0.511s</td>
      <td>299999</td>
    </tr>
    <tr>
      <td>400,000</td>
      <td>0.549s</td>
      <td>399999</td>
    </tr>
    <tr>
      <td>500,000</td>
      <td>0.786s</td>
      <td>499999</td>
    </tr>
    <tr>
      <td>600,000</td>
      <td>0.923s</td>
      <td>599999</td>
    </tr>
    <tr>
      <td>700,000</td>
      <td>0.960s</td>
      <td>699999</td>
    </tr>
    <tr>
      <td>800,000</td>
      <td>1.198s</td>
      <td>799999</td>
    </tr>
    <tr>
      <td>900,000</td>
      <td>1.335s</td>
      <td>899999</td>
    </tr>
    <tr>
      <td>1,000,000</td>
      <td>1.472s</td>
      <td>999999</td>
    </tr>
  </tbody>
</table>

<ol class="keith-deliverables">
  <li>For each of these pieces of code, tell us its big-O runtime as a function of n. No justification is required.</li>
  <li>For each of these pieces of code, tell us whether that function could have given rise to the return values reported in the rightmost column of the table. No justification is required.</li>
  <li>Which of the four functions could be the one we ran? If there‚Äôs just a single option, tell us why that option is right and all the others are wrong. If there‚Äôs multiple options, tell us why those options are possible and the others aren‚Äôt. Justify your answer in at most fifty words.</li>
</ol>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-1" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-1">
   
<ol>
  <li>For each of these pieces of code, tell us its big-O runtime as a function of n. No justification is required.</li>
</ol>

<div class="alert alert-info">
  <p>The runtimes are as follows:</p>
  <ul>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function1</span></code> runs in time O(n).</li>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function2</span></code> runs in time O(n).</li>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function3</span></code> runs in time O(n log n).</li>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function4</span></code> runs in time O(n<sup>2</sup>).</li>
  </ul>

  <p>Some explanations:</p>

  <p>In <code class="language-c++ highlighter-rouge"><span class="n">function1</span></code>, we do n pushes followed by n pops. The cost of each stack operation is amortized O(1), so this means we‚Äôre doing 2n operations at an effective cost of O(1) each for a net total of O(n). The same is true about queue operations; each one takes amortized time O(1), which is why <code class="language-c++ highlighter-rouge"><span class="n">function2</span></code> takes time O(n) as well.</p>

  <p>For <code class="language-c++ highlighter-rouge"><span class="n">function3</span></code>, inserting an element into a set takes time O(log n). This means that the cost of inserting n elements is O(n log n). The cost of iterating over the tree is only O(n), so the net runtime is O(n log n).</p>

  <p>For <code class="language-c++ highlighter-rouge"><span class="n">function4</span></code>, adding n elements to the end of a vector takes time O(n). However, removing from the front of a vector with n elements takes time O(n), since we have to shift all the other elements back one position. This means that the overall runtime is O(n<sup>2</sup>).</p>
</div>

<ol>
  <li>For each of these pieces of code, tell us whether that function could have given rise to the return values reported in the rightmost column of the table. No justification is required.</li>
</ol>

<div class="alert alert-info">
  <p>The answers:</p>
  <ul>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function1</span></code> cannot produce the given output.</li>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function2</span></code> will always produce this output.</li>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function3</span></code> will always produce this output.</li>
    <li><code class="language-c++ highlighter-rouge"><span class="n">function4</span></code> will always produce this output.</li>
  </ul>

  <p>Some explanations:</p>

  <p>In <code class="language-c++ highlighter-rouge"><span class="n">function1</span></code>, since elements are stored in a stack, the last element popped is the first element pushed, which would always be zero. Therefore, we‚Äôd expect to see a column of zeroes in the table, which doesn‚Äôt match what‚Äôs actually there.</p>

  <p>In <code class="language-c++ highlighter-rouge"><span class="n">function2</span></code>, the last element removed from the queue is the last element added to the queue, which, here, would be n ‚Äì 1, matching the output.</p>

  <p>In <code class="language-c++ highlighter-rouge"><span class="n">function3</span></code>, since the Set type is backed by a binary search tree, it stores its elements in sort-ed order. Iterating over the set, therefore, will visit the elements in ascending order, so the last element iterated over by the loop would be n ‚Äì 1, matching the output.</p>

  <p>Finally, in <code class="language-c++ highlighter-rouge"><span class="n">function4</span></code>, we remove elements from the vector in the reverse order in which they‚Äôre added, matching the queue‚Äôs ordering and making the last element visited exactly n ‚Äì 1.</p>
</div>

<ol>
  <li>Which of the four functions could be the one we ran? If there‚Äôs just a single option, tell us why that option is right and all the others are wrong. If there‚Äôs multiple options, tell us why those options are possible and the others aren‚Äôt. Justify your answer in at most fifty words.</li>
</ol>
<div class="alert alert-info">
  <p>Both <code class="language-c++ highlighter-rouge"><span class="n">function2</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">function3</span></code> are plausible here.</p>

  <p>First, notice that the runtime appears to be O(n); doubling the size of the inputs roughly doubles the runtime. However, since runtimes of O(n) and O(n log n) can look pretty similar just given the raw runtime numbers, we can‚Äôt rule out the possibility that the runtime really is O(n log n).</p>

  <p>We know that <code class="language-c++ highlighter-rouge"><span class="n">function1</span></code> can‚Äôt be correct, since it has the wrong return value, and <code class="language-c++ highlighter-rouge"><span class="n">function4</span></code> can‚Äôt be correct because the runtime numbers are inconsistent with an O(n<sup>2</sup>) runtime. Therefore, we ran either <code class="language-c++ highlighter-rouge"><span class="n">function2</span></code> or <code class="language-c++ highlighter-rouge"><span class="n">function3</span></code>.</p>
</div>

</div>
</div>
<hr />

<h2 id="problem-two-rigging-a-tournament">Problem Two: Rigging a Tournament</h2>

<p>This question explores how to use recursion to determine who would win an elimination tournament and, somewhat mischievously, how to set up a tournament so that your favorite player ends up winning.</p>

<p>A <strong><em>tournament bracket</em></strong> is a type of tournament structure for a group of players. The players are lined up in some initial order (here, <strong><em>C, E, A, G, D, F, H, B</em></strong>, as you can see on the left column). The players are paired off by their positions, with the first player competing against the second, the third player competing against the fourth, etc. The winner of each game advances to the next round, and the loser is eliminated. For example, in the first round, player C won her game against player E, player A lost his game against player G, player D won her game against player F, and player H lost his game against player B. Those players are again paired off, making sure to preserve their relative ordering. Thus players C and G and players D and B face off in the second round, with players G and D winning and advancing to the next round. Finally, players G and D face off, and player D emerges victorious. Since she‚Äôs the last player remaining, player D is the overall winner of the tournament.</p>

<p><img src="img/p2_1.png" alt="A tournament bracket -- The first level is C E A G D F H B; C, G, D, and B are winners of that bracket; and then G, D win their battles; and then finally, D emerges victorious." /></p>

<h3 id="part-1-overall-winner-of">Part 1: Overall Winner Of</h3>

<p>Your task in the first part of this problem is to write a <strong><em>recursive</em></strong> function:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">overallWinnerOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input a vector representing the ordering of the players in the initial tournament bracket, then returns the name of player who ends up winning the overall tournament.</p>

<p>In the course of implementing this function, assume you have access to a helper function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">winnerOf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input the names of two players, then returns which of those two players would win in a direct matchup.</p>

<p>Some notes on this problem:</p>

<ul>
  <li>You can assume the number of players is a perfect power of two (for example, 1, 2, 4, 8, 16, 32, 64, etc.), so there will never be a case where there‚Äôs an ‚Äúodd player out‚Äù who isn‚Äôt assigned to play a game in some round. This also means you‚Äôll never get a list of zero players.</li>
  <li>You should not make any assumptions about how a matchup between two players would go based on previous matchups. To determine how a match would go, call the winnerOf function.</li>
  <li>This part of the problem <strong><em>must</em></strong> be implemented recursively ‚Äì that‚Äôs what we‚Äôre testing here. üòÉ</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-2" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-2">
   
<p>There are many ways to solve the first part of this problem. Here are three options.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* To find the winner of a tournament, split the tournament in half. Find the
 * winner in the first and second halves, then have them play a game against
 * one another.
 */</span>
<span class="n">string</span> <span class="nf">overallWinnerOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base Case: If there‚Äôs one player left, that player wins! */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialOrder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">initialOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">initialOrder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">winnerOf</span><span class="p">(</span><span class="n">overallWinnerOf</span><span class="p">(</span><span class="n">initialOrder</span><span class="p">.</span><span class="n">subList</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">half</span><span class="p">)),</span>
                    <span class="n">overallWinnerOf</span><span class="p">(</span><span class="n">initialOrder</span><span class="p">.</span><span class="n">subList</span><span class="p">(</span><span class="n">half</span><span class="p">,</span> <span class="n">half</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* ‚Ä¶ or ‚Ä¶ */</span>

<span class="cm">/* Pair off the players so that each plays a game against the next player in the
 * ordering, then form an elimination tournament from those players in the same
 * relative order and see who wins!
 */</span>
<span class="n">string</span> <span class="nf">overallWinnerOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base Case: If there‚Äôs one player left, that player wins! */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialOrder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">initialOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">nextRound</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">initialOrder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextRound</span> <span class="o">+=</span> <span class="n">winnerOf</span><span class="p">(</span><span class="n">initialOrder</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">initialOrder</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">overallWinnerOf</span><span class="p">(</span><span class="n">nextRound</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ‚Ä¶ or ‚Ä¶ */</span>

<span class="cm">/* Treat the Vector like a Queue! Pull off the first two players, have them play
 * a game against one another, then put the winner on the back. This process will
 * pair off the players in the same order as required by the tournament bracket.
 */</span>
<span class="n">string</span> <span class="nf">overallWinnerOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base Case: If there‚Äôs one player left, that player wins! */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialOrder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">initialOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="cm">/* Drop off the first two players. */</span>
    <span class="k">auto</span> <span class="n">nextRound</span> <span class="o">=</span> <span class="n">initialOrder</span><span class="p">.</span><span class="n">sublist</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">initialOrder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

    <span class="cm">/* Put the winner on the back. */</span>
    <span class="n">nextRound</span> <span class="o">+=</span> <span class="n">winnerOf</span><span class="p">(</span><span class="n">initialOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">initialOrder</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">overallWinnerOf</span><span class="p">(</span><span class="n">nextRound</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

</div>
</div>
<hr />

<h3 id="part-2-can-rig-for">Part 2: Can Rig For</h3>

<p>Changing the initial order of players in a tournament can change the outcome of that tournament. For example, imagine that player A is a very strong player who would win against every player except player G. In the tournament bracket shown to the left, player A immediately gets eliminated from the tournament. On the other hand, in the tournament bracket shown to the right, player A ends up winning the entire tournament, since player G get eliminated before she gets a chance to play a game against player A.</p>

<p><img src="img/p2_2.png" alt="Two tournaments with different initial orders. D wins the first tournament, but in the second tournament, &quot;A&quot; wins because the opponents who defeated them are defeated early by others." /></p>

<p>Because the winner of a tournament depends on the player ordering, in some cases it is possible to ‚Äúrig‚Äù the outcome of a tournament by changing the initial player ordering. For example, if you were a huge fan of player D and wanted her to be the overall winner, and if you knew in advance which opponents player D would win against, you could try different orderings and come up with the bracket to the left. If you wanted player A to be the overall winner, then you could set up the players in the order to the right. In some cases, there‚Äôs nothing you can do to ensure someone will win the tournament. For example, a player who you know will lose every game they play will always lose their first game and be eliminated.</p>

<p>Your task is to write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">canRigFor</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">player</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">allPlayers</span><span class="p">,</span>
               <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input the name of a player and a set containing the names of all the players in the tournament, then returns whether there‚Äôs some initial ordering of the players that will cause that player to be the overall winner. If so, your function should fill in <code class="language-c++ highlighter-rouge"><span class="n">initialOrder</span></code> with one such possible ordering.</p>

<p>Some notes on this problem:</p>
<ul>
  <li>You should make all the same assumptions about the input as in the first part of this problem: the number of players is always going to be a perfect power of two, that you should use the winnerOf function to determine who would win in a matchup, etc.</li>
  <li>Feel free to use the overallWinnerOf function from part (i) of this function in the course of solving this problem, even if you weren‚Äôt able to get a working solution.</li>
  <li>Don‚Äôt worry about efficiency. We‚Äôre expecting you to use brute force here, and no creative optimizations are necessary.</li>
  <li>This part of the problem must be done recursively. Again, that‚Äôs what we‚Äôre aiming to test here.</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-3" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-3">
   
<p>The second part of this problem is essentially a permutations problem: we just list off all possible ways to order the players and see if our favorite player ever wins!</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">canRigFor</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">player</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">allPlayers</span><span class="p">,</span>
               <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">canRigRec</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">allPlayers</span><span class="p">,</span> <span class="n">initialOrder</span><span class="p">,</span> <span class="p">{});</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">canRigRec</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">player</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">allPlayers</span><span class="p">,</span>
               <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">initialOrder</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">soFar</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base Case: If everyone is already placed, see if our player wins! */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">allPlayers</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">overallWinnerOf</span><span class="p">(</span><span class="n">soFar</span><span class="p">)</span> <span class="o">==</span> <span class="n">player</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">initialOrder</span> <span class="o">=</span> <span class="n">soFar</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Recursive case: Try all possible next players. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">nextPlayer</span><span class="o">:</span> <span class="n">allPlayers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">nextOrder</span> <span class="o">=</span> <span class="n">soFar</span><span class="p">;</span>
        <span class="n">nextOrder</span> <span class="o">+=</span> <span class="n">nextPlayer</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">canRigRec</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">allPlayers</span> <span class="o">-</span> <span class="n">nextPlayer</span><span class="p">,</span> <span class="n">initialOrder</span><span class="p">,</span> <span class="n">nextOrder</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* Oh well, guess it‚Äôs not possible. */</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question</em></strong>: We chose this question primarily to make sure that you were comfortable with recursive backtracking and recursive problem-solving strategies. The first part of this problem was designed to assess whether you were comfortable looking at a tree structure and deducing some sort of recursive pattern from it, and we hoped that the fact that there are several different solution routes you can choose from would make that part a good warm-up. The second part of this problem is essentially just a permutations problem, and we hoped that you‚Äôd be comfortable looking over the structure of the problem and recognizing this particular detail.</p>

<p>Fun fact: this problem is based on some research done by one of my former CS103 TAs, Michael Kim, who is currently a Ph.D student here.</p>

<p><strong><em>Common mistakes</em></strong>: Most people got the first part of this problem right, or otherwise had a solution that was almost entirely correct. Nice job! The most common mistakes we saw were choosing the wrong base case (for example, assuming there were always at least two players) or indexing errors in the Vector.</p>

<p>For the second part of the problem, by far the most common mistake we saw was not recognizing that this problem is fundamentally a permutations problem. Solutions that didn‚Äôt approach the problem this way typically were much more complicated and didn‚Äôt correctly try all the necessary options.</p>


</div>
</div>
<hr />

<h2 id="problem-three-self-organizing-lists">Problem Three: Self-Organizing Lists</h2>

<p>YouTube and Facebook have tons of data (literally, if you weigh all the disk drives they use to store things), though most of that data is rarely accessed. When you visit YouTube, for example, the videos that will show up will likely be newer videos or extremely popular older videos, rather than random videos from a long time ago. Your Facebook feed is specifically populated with newer entries, though you can still access the older ones if you‚Äôre willing to scroll long enough.</p>

<p>More generally, data sets are not accessed uniformly, and there‚Äôs a good chance that if some piece of data is accessed once, it‚Äôs going to be accessed again soon. We can use this insight to implement the set abstraction in a way that speeds up lookups of recently-accessed elements. Internally, we‚Äôll store the elements in our set in an unsorted, singly-linked list. Whenever we insert a new element, we‚Äôll put it at the front of the list. Additionally, and critically, whenever we look up an element, we will reorder the list by moving that element to the front. For example, imagine our set holds the strings Ugadi, Rosh Hashanah, Nowruz, Seollal, and Enkutatash in the following order:</p>

<p><img src="img/p3_1.png" alt="A list in the aforementioned order, each cell pointing to the next" /></p>

<p>If we look up Nowruz, we‚Äôd move the cell containing Nowruz to the front of the list, as shown here:</p>

<p><img src="img/p3_2.png" alt="The same list above, but Nowruz is now first. Everything before Nowruz is pushed forward to make room for it." /></p>

<p>If we now do a look up for Nowruz again, since it‚Äôs at the front of the list, we‚Äôll find it instantly, without having to scan anything else in the list.</p>

<p>If we now insert the new element Wep Renpet, we‚Äôd insert it at the front of the list, as shown here:</p>

<p><img src="img/p3_3.png" alt="The same list as above, but now Wep Renpet is at the front." /></p>

<p>Now, if we do a lookup for Seollal, we‚Äôd reorder the list as follows:</p>

<p><img src="img/p3_4.png" alt="The same list, but Seollal has been moved to the front" /></p>

<p>If we do an insertion to add Ugadi, since it‚Äôs already present in the set, we just move it to the front of the list, rather than adding another copy. This is shown here:</p>

<p><img src="img/p3_5.png" alt="The same list as before, but Ugadi is now at the front" /></p>

<p>Finally, to remove an element from the list, we‚Äôd just delete the indicated cell out of the list. For example, deleting Wep Renpet would make the list look like this:</p>

<p><img src="img/p3_6.png" alt="The same list as before, but Wep Renpet is gone. Nothing else has changed in terms of order." /></p>

<p>Your task is to implement this idea as a type called <code class="language-c++ highlighter-rouge"><span class="n">MoveToFrontSet</span></code>. The interface is given at the bottom of this page. You‚Äôre responsible for implementing a constructor and destructor and for implementing the <code class="language-c++ highlighter-rouge"><span class="n">contains</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">add</span></code>, and <code class="language-c++ highlighter-rouge"><span class="n">remove</span></code> member functions.</p>

<p>Some notes on this problem:</p>

<ul>
  <li>Your implementation must use a singly-linked list, not a doubly-linked list, but aside from that you can represent the linked list however you‚Äôd like.</li>
  <li>When doing a move-to-front, you must actually rearrange the cells in the list into the appropriate order. Although it might be tempting to simply swap around the strings stored within those cells, this is significantly less efficient than rewiring pointers, especially for long lists.</li>
  <li>You‚Äôre welcome to add any number of private helper data members, member functions, or member types that you‚Äôd like, but you must not modify the public interface provided to you.</li>
  <li>Your implementations of the member functions in this class do not need to be as efficient as humanly possible, but you should avoid operations that are unnecessarily slow or that use an unreasonable amount of auxiliary memory.</li>
</ul>

<p>As a hint, you may find it useful to have your <code class="language-c++ highlighter-rouge"><span class="n">add</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">remove</span></code> implementations call your <code class="language-c++ highlighter-rouge"><span class="n">contains</span></code> member function and use the fact that it reorganizes the list for you.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MoveToFrontSet</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MoveToFrontSet</span><span class="p">();</span>  <span class="c1">// Creates an empty set</span>
    <span class="o">~</span><span class="n">MoveToFrontSet</span><span class="p">();</span> <span class="c1">// Cleans up all memory allocated</span>

    <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span> <span class="c1">// Returns whether str is present.</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>      <span class="c1">// Adds str if it doesn‚Äôt already exist.</span>
    <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>   <span class="c1">// Removes str if it exists.</span>
<span class="nl">private:</span>
    <span class="cm">/* Add anything here that you‚Äôd like! */</span>
<span class="p">};</span>

<span class="cm">/* Initializes the set so that it‚Äôs empty. */</span>
<span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">MoveToFrontSet</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>

<span class="cm">/* Cleans up all memory allocated by the set. */</span>
<span class="n">MoveToFrontSet</span><span class="o">::~</span><span class="n">MoveToFrontSet</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>

<span class="cm">/* Returns whether the specified element is in the set. If so, reorders the list so
 * that the element is now at the front. If not, the list order is unchanged.
 */</span>
<span class="kt">bool</span> <span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>

<span class="cm">/* Adds the specified element to the list, if it doesn‚Äôt already exist. Either way,
 * the element should end up at the front of the list.
 */</span>
<span class="kt">void</span> <span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
<span class="cm">/* Removes the specified element from the set. If that element doesn‚Äôt exist, this
 * function should have no effect and should not reorder anything.
 */</span>
<span class="kt">void</span> <span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-4" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-4">
   
<p>Here‚Äôs one possible solution:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MoveToFrontSet</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MoveToFrontSet</span><span class="p">();</span>
    <span class="o">~</span><span class="n">MoveToFrontSet</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
    <span class="kt">void</span> <span class="k">delete</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Cell</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">Cell</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="cm">/* Constructor makes the head null to signify that no elements are present. */</span>
<span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">MoveToFrontSet</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="cm">/* Destructor is our typical ‚Äúdeallocate a linked list‚Äù destructor. */</span>
<span class="n">MoveToFrontSet</span><span class="o">::~</span><span class="n">MoveToFrontSet</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Cell</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">bool</span> <span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
 
    <span class="cm">/* Scan the list, keeping track of the current pointer and previous pointer,
     * until we find what we want or fall off the list.
     */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">!=</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="cm">/* If we didn‚Äôt find it, curr will be null since we walked off the list. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 
    <span class="cm">/* If we found it and it‚Äôs not at the head of the list, move that element to
     * the front of the list.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* If this element already exists, we‚Äôre supposed to move it to the front.
     * That‚Äôs automagically handled for us by the contains call!
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Put a new cell at the front of the list. */</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">cell</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MoveToFrontSet</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* See if the element is here. If not, there‚Äôs nothing to do. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">contains</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Nifty fact: the element to remove is now at the front of the list, since
     * looking for it put it there! So just take it off the front.
     */</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">toRemove</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question</em></strong>: We included this question for a number of reasons. First, we wanted to give you a chance to demonstrate what you‚Äôd learned about class design and working with linked lists. We figured this particular problem worked well because it involved linked list manipulations (along the lines of what you did in the Splicing and Dicing assignment) and the idea of having different member functions call one another. Second, we thought this particular linked list exercise of splicing out a node from a singly-linked list and moving it to another location would allow you to demonstrate whether you were comfortable with the idea of maintaining two pointers into a linked list (something you likely needed in the course of building a linked list from scratch) and of rewiring cell pointers. Finally, we thought this problem was interesting in of itself. This is an example of a self-adjusting data structure, and this particular structure is often used in data compression (look up move-to-front encoding). It‚Äôs also related to the more popular splay tree, an extremely fast and simple binary search tree data structure.</p>

<p><strong><em>Common mistakes</em></strong>: We saw a number of solutions that contained memory errors, such as allocating cells unnecessarily (often, pointers were initialized to new Cell rather than nullptr) or reading from a cell after deleting it.</p>

<p>Many solutions attempted to implement contains in terms of insertion and deletion rather than the other way around. While in principle this works, it‚Äôs not at all efficient (it‚Äôs much faster to reorder existing linked list cells than it is to produce new cells from scratch) and makes the logic a lot trickier and therefore more error-prone.</p>


</div>
</div>
<hr />

<h2 id="problem-four-lower-and-upper-bounds">Problem Four: Lower and Upper Bounds</h2>

<p>In a binary search tree, the <strong><em>lower bound</em></strong> of a key is the node in the tree with the smallest value greater than or equal to the key, and the <strong><em>upper bound</em></strong> of a key is the node in the tree with the largest value less than or equal to the key. For example, in the BST shown here, the lower bound of 137 is the node containing 143, and the upper bound of 137 is the node containing 110.</p>

<p><img src="img/p4_1.png" alt="The BST. The parent is 106. Its left and right children are 103 and 110, respectively. 103 has only a left child, 51, whose children are 41 and 52. Meanwhile, 110 has two children (108 and 166). 108 also has two children, 107 and 109, whereas 166 has only a left child, 154. Finally, 154 has two children, 143 and 161." /></p>

<p>If the key is less than all the values, its upper bound is <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>, so the upper bound of 15 is <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>. (The lower bound of 15 is the node containing 41.)</p>

<p>Similarly, if the key is greater than all elements in the BST, its lower bound is nullptr. For example, the lower bound of 261 is nullptr. (The upper bound of 261 is the node containing 166.)</p>

<p>In the event that the key happens to appear inside the BST, then the key itself is its own lower bound and upper bound. For example, the lower and upper bounds of 106 are each the node containing 106.</p>

<p>It is a bit confusing that a key‚Äôs lower bound is always at least as large as its upper bound, but, alas, that is the naming convention we use.</p>

<p>Your task is to implement a function:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bounds</span> <span class="nf">boundsOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes in a pointer to the root of a BST, along with an integer key, then returns the lower and upper bound of that key in the tree. Here, <code class="language-c++ highlighter-rouge"><span class="n">Node</span></code> and <code class="language-c++ highlighter-rouge"><span class="n">Bounds</span></code> are structs defined as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>   
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>  
    <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span> 
    <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Bounds</span> <span class="p">{</span>      
    <span class="n">Node</span><span class="o">*</span> <span class="n">upperBound</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">lowerBound</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Some notes on this problem:</p>
<ul>
  <li>For full credit, your implementation should run in time O(h), where h is the height of the tree. This means that you can‚Äôt necessarily explore the whole tree to find the upper and lower bounds. Due to how a BST is structured, though, you shouldn‚Äôt need to check every node.</li>
  <li>You may want to draw some pictures before diving into this problem. In particular, think about the recursive intuition for how BSTs are structured.</li>
  <li>There can be any number of nodes in the tree, including zero, and there are no restrictions on what the key can be.</li>
  <li>For full credit, you should not use any of the container types (<code class="language-c++ highlighter-rouge"><span class="n">Map</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Lexicon</span></code>, etc.).</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-5" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-5">
   
<p>There are many ways of solving this problem, and we‚Äôve included four of them in this solutions set!</p>

<p>These first two solutions are based on the idea that finding the bounds in a tree is very, very similar to running a binary search in an array. In a binary search in an array, we have two pointers representing the range where the element can be. At each point in time, we probe the midpoint of the range and decide how to adjust the bounds based on how the comparison goes.</p>

<p>We can adapt that same idea here. The difference is that instead of storing indices of the bounds, we‚Äôll store pointers to nodes representing those bounds. Instead of choosing the midpoint of the range, we‚Äôll pick whatever the root of the tree happens to be.</p>

<p>There are several ways to code this approach up. This first one is recursive, and the second iterative:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Returns the upper and lower bounds of the node, given that we know that all
 * elements in the tree are bounded from below and above by the specified nodes.
 */</span>
<span class="n">Bounds</span> <span class="nf">boundsRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">upper</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">lower</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base case: If we're out of nodes, whatever bounds we've discovered are
     * correct.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower</span> <span class="p">};</span>

    <span class="cm">/* Base case: If we have an exact match for the value, the current node is
     * both the upper and lower bound.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span> <span class="p">};</span>

    <span class="cm">/* Recursive case: If the value is too small, then the root node is going to
     * be the lower bound unless we come across something even smaller.
     */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">boundsRec</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* Recursive case: If the value is too big, then the root node is going to be
     * the upper bound unless we come across something even bigger.
     */</span>
    <span class="k">else</span> <span class="cm">/* key &gt; root-&gt;value */</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">boundsRec</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">lower</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Bounds</span> <span class="nf">boundsOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">boundsRec</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the iterative version. Note the similarity to binary search.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bounds</span> <span class="nf">boundsOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Bounds found so far. */</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If we match exactly, great! We're done. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span> <span class="p">};</span>
 
        <span class="cm">/* Otherwise, we have to go left or right. Adjust the lhs
         * and rhs accordingly.
         */</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="cm">/* key &gt; root-&gt;value */</span> <span class="p">{</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="p">{</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This next solution is based on a different insight that follows from the recursive definition of a binary search tree. First, if the tree is empty, then the bounds of the key we‚Äôre looking for are both null, since there‚Äôs nothing bigger or smaller than the key.</p>

<p>Otherwise, the tree consists of a node with two subtrees. Think about how the key relates to the parts of this schematic. If the key matches the root, then the root is both the upper and lower bound of the key. Otherwise, the key isn‚Äôt a match. Let‚Äôs suppose, just for expository purposes, that the key is less than the root. That tells us several things:</p>

<ol>
  <li>The root can‚Äôt be the upper bound of the key. Why? Because the root is too big.</li>
  <li>The upper bound of the key, wherever it is, has to be in the left subtree. Why? Because the upper bound can‚Äôt be the root node (it‚Äôs too big), nor can in be in the right subtree (because those values are all bigger than the root, which is already too big.)</li>
  <li>The root might be the lower bound of the key, since it‚Äôs bigger than the key, but only if nothing in the left subtree is both bigger than the key and less than the root.</li>
</ol>

<p>Based on these insights, we can build a different recursive algorithm that works by descending into the appropriate subtree and, optionally, patching up one of the upper or lower bounds.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bounds</span> <span class="nf">boundsOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
   <span class="cm">/* Looking in an empty tree? Looking at something that's an exact
    * match? Then you have your answer.
    */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span> <span class="p">};</span>
 
   <span class="cm">/* If the key should be in the left subtree, get the bounds purely for
    * that subtree, then see whether we should act as the lower bound.
    */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">boundsOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">lowerBound</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
       <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="cm">/* Otherwise, it's in the right subtree. Use similar logic to the above. */</span>
   <span class="k">else</span> <span class="cm">/* key &gt; root-&gt;value */</span> <span class="p">{</span>
       <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">boundsOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">upperBound</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">result</span><span class="p">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
       <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You could also implement the above idea as two separate helper functions, as shown here:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">upperBoundOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Got an empty tree? Have an exact match? We're done. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

    <span class="cm">/* Otherwise, if the key is less than the root, the bound is
     * purely in the left subtree because we're too big to be a bound.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">upperBoundOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Otherwise, we're bigger than the root. The root node may then
     * be the upper bound if one isn't found in the subtree.
     */</span>
    <span class="k">else</span> <span class="cm">/* key &gt; root-&gt;value */</span> <span class="p">{</span>
       <span class="n">Node</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">upperBoundOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
       <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">?</span> <span class="n">root</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="n">Node</span><span class="o">*</span> <span class="nf">lowerBoundOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Got an empty tree? Have an exact match? We're done. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>

    <span class="cm">/* Otherwise, if the key is greater than the root, the bound is
     * purely in the right subtree because we're too small to be a bound.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lowerBoundOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Otherwise, we're smaller than the root. The root node may then
     * be the lower bound if one isn't found in the subtree.
     */</span>
    <span class="k">else</span> <span class="cm">/* key &lt; root-&gt;value */</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">lowerBoundOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">?</span> <span class="n">root</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="n">Bounds</span> <span class="nf">boundsOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">upperBoundOf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
        <span class="n">lowerBoundOf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question</em></strong>: We included this question for a few different reasons. First, we wanted to let you show us what you‚Äôd learned about binary search trees and their structural properties. Could you navigate down a BST based on how a particular key relates to the root value? Could you propagate information up through a series of recursive calls?</p>

<p>Second, we wanted to give you a chance to work through an algorithmic question involving binary search trees. You weren‚Äôt expected to immediately see how to compute the bounds of a particular key, but we hoped that your intuition about BSTs would help you determine what questions would be best to ask to arrive at a solution.</p>

<p><strong><em>Common mistakes</em></strong>: There were two general classes of mistakes on this problem. First, there were regular, run-of-the-mill coding errors. Second, there were more problem-specific algorithmic concerns.
Let‚Äôs begin with the coding errors. Perhaps the most common error we saw on this problem was trying to treat an object of type Bounds as a pointer. For example, we saw many solutions that included a line like this one:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">‚ö†</span>        <span class="n">Bounds</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bounds</span><span class="p">;</span>       <span class="err">‚ö†</span>
</code></pre></div></div>
<p>Here, the variable <code class="language-c++ highlighter-rouge"><span class="n">result</span></code> is an honest-to-goodness <code class="language-c++ highlighter-rouge"><span class="n">Bounds</span></code> object, not a pointer to one, so it doesn‚Äôt need to be (and in fact, can‚Äôt legally be) initialized using the <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> keyword. Remember, the <code class="language-c++ highlighter-rouge"><span class="k">new</span></code> keyword produces a pointer, so this statement tries to assign a pointer (<code class="language-c++ highlighter-rouge"><span class="k">new</span> <span class="n">Bounds</span></code>) to a non-pointer (<code class="language-c++ highlighter-rouge"><span class="n">result</span></code>). We suspect that people got tripped up here because <code class="language-c++ highlighter-rouge"><span class="n">Bounds</span></code> is a struct that contains pointers, but which itself is not actually a linked structure.</p>

<p>Second, we saw a number of solutions that forgot to handle the case where the tree was empty. Some solutions legitimately forgot to account for this case, while others attempted to handle it but did so incorrectly. For example, we saw many submissions that included code fragments like these:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">‚ö†</span>      <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span> <span class="p">};</span>          <span class="err">‚ö†</span>
<span class="err">‚ö†</span>      <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">};</span>         <span class="err">‚ö†</span>
</code></pre></div></div>
<p>We call this the ‚Äúshoot first and ask questions later approach,‚Äù since you‚Äôre following the <code class="language-c++ highlighter-rouge"><span class="n">root</span></code> pointer (shooting) before you determine whether it‚Äôs not null (asking questions). This code will crash in the case that <code class="language-c++ highlighter-rouge"><span class="n">root</span></code> is null, since the the first line tries to dereference the pointer.</p>

<p>A more minor error we saw was mixing up <code class="language-c++ highlighter-rouge"><span class="n">Node</span><span class="o">*</span></code> pointers, which represent pointers to nodes in the tree, with the integer values they contain. Sometimes we‚Äôd see people assigning numeric values to pointers, and (more frequently) we‚Äôd see solutions that compared integer keys directly against pointers.</p>

<p>We also saw some common recursive errors, such as making recursive calls and forgetting to return the value of the recursive call.</p>

<p>Let‚Äôs now turn to algorithmic errors. The most common algorithmic mistake we saw on this problem arose when people tried to look at the root and one of its children to try to size up where one of the bounds must be. For example, we saw many solutions along these lines:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">‚ö†</span>       <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>                                           <span class="err">‚ö†</span>
<span class="err">‚ö†</span>           <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>        <span class="err">‚ö†</span>
<span class="err">‚ö†</span>               <span class="c1">// lower bound is root                                     ‚ö†</span>
<span class="err">‚ö†</span>           <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                                       <span class="err">‚ö†</span>
<span class="err">‚ö†</span>               <span class="c1">// recursively explore left subtree                        ‚ö†</span>
<span class="err">‚ö†</span>           <span class="p">}</span>                                                              <span class="err">‚ö†</span>
<span class="err">‚ö†</span>       <span class="p">}</span>                                                                  <span class="err">‚ö†</span>
</code></pre></div></div>
<p>The idea here is the following. Suppose we know that the key is less than the root‚Äôs value. What node, then, is the lower bound of the key? The root node‚Äôs value is bigger than the key, so it‚Äôs a candidate for being the lower bound. So how do we tell if there‚Äôs a better one? Well, if there‚Äôs no left child, then there‚Äôs nothing smaller than the root, so the root is the lower bound, and if there is a left child and the key‚Äôs value is sandwiched between the left child and the root, then the root should be the lower bound.</p>

<p>Everything in the above paragraph is correct, <em>except</em> for the last part of the last sentence. For example, consider the BST shown below. Now, what is the lower bound of 15? The correct answer should be the node containing 15, but if we use the above code, we‚Äôll incorrectly report that the root is the lower bound because the key (15) is sandwiched between the left child‚Äôs value and the root‚Äôs value. That is, we have to look deeper in the tree to find the true lower bound. On the other hand, what‚Äôs the lower bound of 16? In that case, the correct answer actually is the root, even though, as above, the key is sandwiched between the root‚Äôs value and the left subtree‚Äôs value. However, we can only tell that because we can look deeper in the tree to see what other nodes are there.</p>

<p><img src="img/p4a_1.png" alt="A tree with 20 as its root, with only a left child (10), which in turn only has a right child (15)" /></p>

<p>The reason for mentioning both cases here is that finding a bound in a tree can be tricky and isn‚Äôt something you can typically do by looking at a single pair of linked nodes. Just knowing a key is between two nodes in the tree doesn‚Äôt mean that one of those nodes has to be the bound. You may need to look more extensively in the tree to find the bound.</p>

<p>There was one last class of error we encountered that belongs to the category of ‚Äúthe code isn‚Äôt wrong, but it‚Äôs much more complex than it needs to be.‚Äù We saw many recursive implementations that, before descending into a left or right subtree, would check that the current node was a better lower / upper bound, respectively, than the best bound found so far. However, it‚Äôs not necessary to do this. For example, if you find that the key is less than the root‚Äôs value and move to the left, then the root node is <em>guaranteed</em> to be a better lower bound than whatever lower bound has been discovered so far. (Do you see why?) Similarly, if you find that the key is greater than the root‚Äôs value and move to the right, then the root node is <em>guaranteed</em> to be a better upper bound than whatever‚Äôs been discovered so far. (Do you see why?)</p>


</div>
</div>
<hr />

<h2 id="problem-five-workout-playlists">Problem Five: Workout Playlists</h2>

<p>On Assignment 4, you wrote recursive code to determine whether it was possible to find objects of various types. This question serves as a coda to our treatment of recursive exploration and is designed to let you show us what you‚Äôve learned in the process.</p>

<p>You‚Äôd like to put together a playlist for your next workout. You‚Äôd like to design the playlist so that</p>
<ul>
  <li>its length is <strong><em>exactly equal</em></strong> to the length of your workout, and</li>
  <li>no song appears too many times in the playlist.</li>
</ul>

<p>How many times is ‚Äútoo many times?‚Äù That depends. For a short workout, you might not want to hear the same song multiple times. For a long workout, you might be okay hearing the same song three or even four times. We‚Äôll assume that when you sit down to start creating the playlist, you‚Äôll have some magic number in mind.</p>

<p>Write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">canMakePlaylist</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songLengths</span><span class="p">,</span>  
                     <span class="kt">int</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxTimes</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input a list of the lengths of the songs you‚Äôre considering putting on your playlist, along with the length of your workout and the maximum number of times you‚Äôre comfortable hearing a particular song. The function then returns whether there‚Äôs a playlist of <strong><em>exactly</em></strong> length <code class="language-c++ highlighter-rouge"><span class="n">workoutLength</span></code> which doesn‚Äôt include any song more than <code class="language-c++ highlighter-rouge"><span class="n">maxTimes</span></code> times.</p>

<p>Some notes on this problem:</p>
<ul>
  <li>You must implement this function recursively.</li>
  <li>You can assume that workoutLength ‚â• 0, that maxTimes ‚â• 0, and that the length of each song is also greater than or equal to zero. You don‚Äôt need to handle the case where any of these quantities are negative.</li>
  <li>There can be any number of songs in songLengths, including zero.</li>
  <li>You just need to tell us whether there is a possible playlist with the given length, not what songs are on that playlist or what order you‚Äôd put them in.</li>
  <li>Each song may appear multiple times, and not all songs necessarily need to be used.</li>
  <li>The total length of all songs in your playlist should equal workoutLength. Note that this is not the same thing as saying that the total number of songs in your playlist should equal workoutLength.</li>
  <li>Be careful ‚Äì greedy solutions won‚Äôt work here. There are combinations of song lengths, workout lengths, and maximum repeat counts where the only way to build a playlist of exactly the right length is to use fewer copies of a particular song than you‚Äôre allowed to.</li>
  <li>Your solution does not need to be as efficient as possible, but to receive full credit your solution must not use a recursive strategy that is needlessly inefficient.</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-6" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-6">
   
<p>An interesting aspect of this problem is that we aren‚Äôt required to actually return the playlist. We just need to see whether one exists. And if that‚Äôs the case, we don‚Äôt actually care about the order in which the songs appear in the playlist, just how many times each song appears. (Do you see why?)</p>

<p>This first recursive solution works by going one song at a time, asking how many times we‚Äôll use it.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Can we add up to exactly the workout length using only songs from index
 * start and forward?
 */</span>
<span class="kt">bool</span> <span class="nf">canMakeRec</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songLengths</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span>
                <span class="kt">int</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxTimes</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base case: If the length is zero, yes, we can make it! Just have
     * a playlist with no songs on it.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">workoutLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="cm">/* Base case: If we're out of songs, then no, we can't make it! */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">songLengths</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="cm">/* Recursive case: We need to determine how many times to use this first
     * song. See what those options are.
     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">times</span> <span class="o">&lt;=</span> <span class="n">maxTimes</span><span class="p">;</span> <span class="n">times</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If this will take too much time, stop searching. We know that using
         * it any more times will only make things worse.
         */</span>
        <span class="kt">int</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">songLengths</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">*</span> <span class="n">times</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">duration</span> <span class="o">&gt;</span> <span class="n">workoutLength</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="cm">/* Otherwise, see what happens if we include this song that many times. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">canMakeRec</span><span class="p">(</span><span class="n">songLengths</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">workoutLength</span> <span class="o">-</span> <span class="n">duration</span><span class="p">,</span> <span class="n">maxTimes</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* If we're here, no options worked. */</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">canMakePlaylist</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songLengths</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxTimes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">canMakeRec</span><span class="p">(</span><span class="n">songLengths</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="n">maxTimes</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This next solution is based on the idea that we‚Äôll build up the playlist one song at a time, repeatedly choosing a next song that doesn‚Äôt exceed the time limit and making sure not to exceed our allotment. One of the challenges here is that multiple songs might have the same length, so we need to do some extra bookkeeping to track how many times each song has appeared on the playlist so far.</p>

<p>This approach is not as fast as the other one, so we <strong><em>would not</em></strong> award full credit. In particular, note that this will generate the same playlist multiple times, requiring a lot of extra work to compute the solution. Do you see why?</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Can you make a playlist whose total length is exactly workoutLength using
 * each song at most maxTimes times, given that the playlist already contains
 * some number of copies of each song?
 *
 * The playlist is encoded as a list of the indices into the songLengths list.
 */</span>
<span class="kt">bool</span> <span class="nf">canMakeRec</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songLengths</span><span class="p">,</span>
                <span class="kt">int</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxTimes</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">soFar</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base case: If the length of our playlist so far happens to match the
     * length of workout, we're done.
     */</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">lengthOf</span><span class="p">(</span><span class="n">soFar</span><span class="p">,</span> <span class="n">songLengths</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="n">workoutLength</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 
    <span class="cm">/* Base case: If the current playlist is too long, it can't possibly
     * work.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">workoutLength</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 
    <span class="cm">/* Recursive case: Try each song that doesn't appear too many times. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">songLengths</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Can we fit this in? Or have we used it too much? */</span>
        <span class="kt">int</span> <span class="n">copies</span> <span class="o">=</span> <span class="n">copiesOf</span><span class="p">(</span><span class="n">soFar</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copies</span> <span class="o">&lt;</span> <span class="n">maxTimes</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">nextList</span> <span class="o">=</span> <span class="n">soFar</span><span class="p">;</span>
            <span class="n">nextList</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
 
            <span class="k">if</span> <span class="p">(</span><span class="n">canMakeRec</span><span class="p">(</span><span class="n">songLengths</span><span class="p">,</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="n">maxTimes</span><span class="p">,</span> <span class="n">nextList</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="cm">/* Oh fiddlesticks. */</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="cm">/* Given a list of which songs to play in the playlist, returns how long
 * the playlist is.
 */</span>
<span class="kt">int</span> <span class="nf">lengthOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songIndices</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songLengths</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">:</span> <span class="n">songIndices</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">songLengths</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Given a list of songs to play, returns how many times the given song
 * appears.
 */</span>
<span class="kt">int</span> <span class="nf">copiesOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songIndices</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">song</span><span class="o">:</span> <span class="n">songIndices</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">song</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="n">result</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">bool</span> <span class="nf">canMakePlaylist</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">songLengths</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxTimes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">canMakeRec</span><span class="p">(</span><span class="n">songLengths</span><span class="p">,</span> <span class="n">workoutLength</span><span class="p">,</span> <span class="n">maxTimes</span><span class="p">,</span> <span class="p">{});</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question</em></strong>: We included this question as a final wrap-up to our treatment of recursive exploration. We hoped that this problem, which is very much in the same spirit as the questions on the midterm, would be a great way for folks to show how much they‚Äôd learned since the start of the quarter.</p>

<p><strong><em>Common mistakes</em></strong>: Although many solutions treated this as a permutations problem, that‚Äôs not the best fit for this problem because the order of the songs doesn‚Äôt matter. Specifically, the total length of a playlist purely depends on the total lengths of the songs on that playlist, not the order in which they appear.</p>

<p>We also saw a number of solutions that approached this problem in a way that did introduce unnecessary inefficiencies. For example, some solutions would never check the total length of the playlist they‚Äôd produced until the very end of the recursion, focusing much of the search effort on dead-ends that couldn‚Äôt pan out. We did deduct points for solutions like these, as they could be significantly improved with very little code without impacting the overall recursive strategy.</p>

<p>Aside from these efficiency concerns, the most common error was not handling the case where there were multiple songs with the same length in the songLengths vector. For example, solutions that tracked frequencies by associating each length with its frequency wouldn‚Äôt work correctly if, for example, there were two songs that were exactly three minutes long.
We also saw a number of solutions that approached this problem in a way that did introduce unnecessary inefficiencies. For example, some solutions would never check the total length of the playlist they‚Äôd produced until the very end of the recursion, focusing much of the search effort on dead-ends that couldn‚Äôt pan out. We did deduct points for solutions like these, as they could be significantly improved with very little code without impacting the overall recursive strategy.
Aside from these efficiency concerns, the most common error was not handling the case where there were multiple songs with the same length in the songLengths vector. For example, solutions that tracked frequencies by associating each length with its frequency wouldn‚Äôt work correctly if, for example, there were two songs that were exactly three minutes long.
Besides these problem-specific errors, we saw a number of general recursive issues here. Some solutions contained unconditional return statements inside of a for loop, cutting off the search too early. Others modified data across recursive calls in ways that caused future recursive calls to have incorrect information passed down into them. Otherwise interchanged the order of base cases in a way that caused the code to not work as expected.</p>

<p>Besides these problem-specific errors, we saw a number of general recursive issues here. Some solutions contained unconditional return statements inside of a for loop, cutting off the search too early. Others modified data across recursive calls in ways that caused future recursive calls to have incorrect information passed down into them. Otherwise interchanged the order of base cases in a way that caused the code to not work as expected.</p>


</div>
</div>
<hr />

<h2 id="problem-six-binary-heaps">Problem Six: Binary Heaps</h2>

<p>In Assignment 6, you implemented the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> type using a binary heap. As a refresher from that assignment, the <code class="language-c++ highlighter-rouge"><span class="n">HeapPQueue</span></code> stored objects of type <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code>, where <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> is given as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">DataPoint</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>   
<span class="p">};</span>
</code></pre></div></div>
<p>We‚Äôve created a binary heap storing these six <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> objects:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="s">"Emu"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span>       <span class="p">{</span> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span>       <span class="p">{</span> <span class="s">"Cow"</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span>
<span class="p">{</span> <span class="s">"Yak"</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span>       <span class="p">{</span> <span class="s">"Doe"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>       <span class="p">{</span> <span class="s">"Ewe"</span><span class="p">,</span> <span class="mi">6</span> <span class="p">}</span>
</code></pre></div></div>
<p>These elements were inserted into the binary heap in some order, but you don‚Äôt know what that order is.
Below is a picture of the shape of the binary heap holding these elements, but not what DataPoints are stored in each of the nodes. Each node has been assigned a letter so that we have a nice way to refer to it later; otherwise, the letters have no special meaning.</p>

<p><img src="img/p6_1.png" alt="Node A is the root. Nodes B and C are its left and right children. B has two children, D and E; C has only a left child, F." /></p>

<p>Regardless of the order in which we inserted the above six elements into the binary heap, we are guaranteed that <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Emu"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span></code> will end up in Node <strong><em>A</em></strong> due to the rules of how binary heaps work. Your task is to determine where other elements may end up.</p>

<p>Answer each of the following questions. No justification is needed. Incorrect answers will not receive points, but otherwise there is no penalty for an incorrect guess.</p>
<ol>
  <li><strong>(1 Point)</strong> In the space below, list the letters of all nodes that may contain <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span></code>.</li>
  <li><strong>(1 Point)</strong> In the space below, list the letters of all nodes that may contain <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Doe"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span></code>.</li>
</ol>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-7" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-7">
   
<ol>
  <li><strong>(1 Point)</strong> In the space below, list the letters of all nodes that may contain <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span></code>.</li>
</ol>

<div class="alert alert-info">
  <p>Answer: <strong><em>Node B and Node C</em></strong>.</p>

  <p>There is only one <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> whose weight is less than that of <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span></code>, and that‚Äôs <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Emu"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span></code>. As a result, <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span></code> can‚Äôt go in nodes <em>D, E, or F</em>, since anything going in one of those two nodes would have to have two other DataPoints with lower weight (the immediate parent, plus node A). Additionally, <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span></code> can‚Äôt go in Node A, since that‚Äôs where <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Emu"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span></code> goes. Therefore, the only options are B and C. To convince yourself that it‚Äôs possible for {<code class="language-c++ highlighter-rouge"> <span class="s">"Auk"</span><span class="p">,</span> <span class="mi">2</span> <span class="err">}</span></code> to go there, we‚Äôd recommend drawing out some sample heaps where this actually happens.</p>
</div>

<ol>
  <li><strong>(1 Point)</strong> In the space below, list the letters of all nodes that may contain <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Doe"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span></code>.</li>
</ol>

<div class="alert alert-info">
  <p>Answer: <strong><em>Node C, Node D, node E, and node F.</em></strong></p>

  <p>Using similar reasoning to the above answer, there is only one <code class="language-c++ highlighter-rouge"><span class="n">DataPoint</span></code> whose weight is greater than <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Doe"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span></code>, and that‚Äôs <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Ewe"</span><span class="p">,</span> <span class="mi">6</span> <span class="p">}</span></code>. Therefore, <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Doe"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span></code> can‚Äôt go anywhere that has two or more children, since there aren‚Äôt enough items to fill those spots. That rules out Node A and Node B. To confirm the rest of the options are possible, you can quickly sketch out different binary heaps that indeed place <code class="language-c++ highlighter-rouge"><span class="p">{</span> <span class="s">"Doe"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span></code> in each spot.</p>
</div>

<p><strong><em>Why we asked this question</em></strong>: This question was designed to see if you were comfortable with how the rules for binary heaps worked. Unlike binary search trees, which have very strict rules about which elements can go where, binary heaps have fairly lax rules and there‚Äôs a lot of flexibility about where items can go. You can solve this problem either by drawing lots of binary heaps and watching what happens, or by looking at the structural properties of the tree to figure out what goes where, or both!</p>


</div>
</div>
<hr />

<h2 id="problem-seven-word-walks">Problem Seven: Word Walks</h2>
<h3 id="part-1-overlapping-words">Part 1: Overlapping Words</h3>

<p>Your first task in this question is to finish an implementation of a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">wordsOverlap</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes as input two words, then returns whether the last letters of the string left overlap with the first letters of the string right. For example, the strings "wonder" and "derby" overlap like this:</p>
<pre>
won<strong>der</strong>  
   <strong>der</strong>by
</pre>
<p>The words "orange" and "angel" overlap like this:</p>
<pre>
or<strong>ange</strong>
  <strong>ange</strong>l
</pre>
<p>The words "violin" and "naqareh" overlap like this:</p>
<pre>
violi<strong>n</strong>      
     <strong>n</strong>aqareh
</pre>
<p>The words "aa" and "aardvark" can overlap in two different ways:</p>
<pre>
a<strong>a</strong>              <strong>aa</strong>      
 <strong>a</strong>ardvark       <strong>aa</strong>rdvark
</pre>
<p>Any word overlaps with itself; for example, here‚Äôs "springbok" overlapping itself:</p>

<pre>
<strong>springbok
springbok</strong>
</pre>
<p>We‚Äôve given a partial implementation of this function in the space below. Please fill in the rest of this implementation by filling in the blanks. Do not add, remove, or edit code anywhere else.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">wordsOverlap</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">______________________</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">________</span><span class="p">)</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">_______</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-8" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-8">
   
<p>Here‚Äôs one possible answer:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">wordsOverlap</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">right</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Another option:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">wordsOverlap</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Both options work by trying all nonempty suffixes of <code class="language-c++ highlighter-rouge"><span class="n">left</span></code> and nonempty prefixes of <code class="language-c++ highlighter-rouge"><span class="n">right</span></code>.</p>

<p>This third option uses the fact that the <code class="language-c++ highlighter-rouge"><span class="n">string</span><span class="o">::</span><span class="n">substr</span></code> function will trim the length of the substring to never exceed the length of the input string:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">wordsOverlap</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>


</div>
</div>
<hr />

<h3 id="part-2-word-walk">Part 2: Word Walk</h3>

<p>If you have a collection of words, you can form a word walk by ordering the words so that each pair of consecutive words overlap. Here‚Äôs a few sample word walks; I promise these are all English words. üòÉ</p>

<pre><code class="language-plain">absorbants
      antsiest
         siestas
            stash
              ashiness
                   essentials
                          also
</code></pre>

<p>Another example:</p>
<pre><code class="language-plain">euchromatic
        ticktacking
               kingbolt
                   boltonia
                        niacin
                           cinnamyl
                                mylonite
</code></pre>

<p>And another:</p>
<pre><code class="language-plain">tenorite
      termers
          erst
            startlingly
                      yogas
                          synaloephas
                                    simpering
</code></pre>

<p>In extreme cases, you might have one word fully subsume another; here‚Äôs an example of this:</p>
<pre><code class="language-plain">preponderate
preponderated
      derated
        rated
          tediously
                slyest
                    stepson
</code></pre>

<p>Your task is to write a function:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">canMakeWordWalkFrom</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">);</span>
</code></pre></div></div>

<p>that takes in a <strong><em>nonempty</em></strong> set of words, then returns whether it‚Äôs possible to form a word walk that uses all the words in that set exactly once.</p>

<p>Some notes on this problem:</p>
<ul>
  <li>Feel free to use the <code class="language-c++ highlighter-rouge"><span class="n">overlapsWith</span></code> function from the previous part of this problem in your solution. You can assume that function works correctly.</li>
  <li>Your function simply needs to tell us whether it‚Äôs possible to form a word walk using each of the given words exactly once. It doesn‚Äôt need to tell us what that walk is, if it exists.</li>
  <li>You can assume the input <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code> contains at least one word and don‚Äôt need to handle the case where the <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code> is empty.</li>
  <li>Your solution does not need to be as efficient as possible, but solutions that contain large inefficiencies will not receive full credit.</li>
  <li>You do need to solve this problem recursively; that‚Äôs kinda what we‚Äôre testing here. üòÉ</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-9" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-9">
   
<p>There are a couple of different strategies you can use to solve this problem. This first approach works by having a wrapper function that places down the first word in the walk, then using recursion to see whether the rest of the words can be extended from there.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">canMakeWordWalkFrom</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Can we make a word walk starting with this word? */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">canMakeRec</span><span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="n">word</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Can we make a word walk using the remaining words, given knowledge of the
 * previous word? Note that we don't have to store the whole walk, since we just
 * need to see whether one exists and don't need to report it.
 */</span>
<span class="kt">bool</span> <span class="nf">canMakeRec</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">remaining</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lastWord</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base case: If there are no words left, great! We've used them all. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="cm">/* Otherwise, some word comes next. Which one is it? */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="o">:</span> <span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If we can use this word, and we can make a word walk from the remaining
         * words, great! We're done.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">overlapsWith</span><span class="p">(</span><span class="n">lastWord</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">canMakeRec</span><span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="n">word</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Oh fiddlesticks; nothing works. */</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs another solution. This one works by explicitly tracking the full word walk. It makes a special case of the first word in the walk, which can be selected arbitrarily.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">canMakeWordWalkFrom</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">canMakeRec</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="p">{});</span>
<span class="p">}</span>

<span class="cm">/* Can we make a word walk using the remaining words given the walk built up so
 * far?
 */</span>
<span class="kt">bool</span> <span class="nf">canMakeRec</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">remaining</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">chosen</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base case: If there are no words left, great! We've used them all. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="cm">/* Otherwise, some word comes next. Which one is it? */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="o">:</span> <span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* We can use this word if it comes first, or if it overlaps the previous
         * word.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">chosen</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span> <span class="o">||</span> <span class="n">overlapsWith</span><span class="p">(</span><span class="n">chosen</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">word</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* It's a candidate. Can we take it from here? */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">canMakeRec</span><span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="n">word</span><span class="p">,</span> <span class="n">chosen</span> <span class="o">+</span> <span class="n">word</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Alas, nothing works. */</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question</em></strong>: This question was designed to let you show us what you‚Äôd learned about recursive backtracking. The general structure of the recursion here (try all options, see if any of them work, and return true if any of them do) is a nice match onto the backtracking approaches you saw in Assignment 4. There are a couple nuances here ‚Äì how you handle the first word in the sequence, for example ‚Äì that add some complexity, but fortunately there are many ways to code this one up.</p>

<p><strong><em>Common mistakes</em></strong>: For part (i) of this problem, one of the most common mistakes we encountered was simply forgetting to include i as part of the expression for the for loop bound. For example, we saw many loops like this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">min</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">right</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="err">‚Ä¶</span> <span class="p">}</span> <span class="c1">// ‚ö† Oops!</span>
</code></pre></div></div>
<p>For part (i) of this problem, we saw several classes of errors. One subtle error was to choose the base case to be when the set of strings contains exactly one remaining string. While it‚Äôs true that any set of one string forms a word walk, in the context of the recursive search if you have only one string left you still need to ensure that it can be linked into the other words chained together so far.</p>

<p>On that subject, another common mistake on this problem was not keeping track of information of the partial word walk built up so far. To get this function to work correctly, you need some mechanism for tracking what words have been added to the word walk (or just the last word added, or the first and last words added, depending on your approach). Without this information, it‚Äôs hard to use recursion to solve the problem. Even if you can pull out a single word and form a word walk from what‚Äôs left, you can‚Äôt guarantee that the walk you formed that way can be extended into a larger walk by inserting the word you left out.</p>

<p>The most common efficiency issue we saw in this problem were solutions that worked by building up a full permutation of all the words, only checking whether that permutation is a word walk at the end. While this works, this will cause the algorithm to spend a huge amount of time building permutations that can‚Äôt possibly work out. For example, if the first two words in the permutation don‚Äôt overlap, then there‚Äôs no reason to keep adding words onto the end, as no matter what you do you can‚Äôt form a word walk that way. This isn‚Äôt only a theoretical concern; without checking as you go to make sure the word walk can be extended, you‚Äôll end up exploring an enormous number of options that don‚Äôt pan out.</p>

<p>We also saw a number of solutions that returned results too early in a way that prevented the code from searching over all possible options. For example, many solutions contained code like this:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ‚ö†‚ö†‚ö†</span>
<span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">word</span><span class="o">:</span> <span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>                             
    <span class="k">if</span> <span class="p">(</span><span class="n">overlapsWith</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span> <span class="p">{</span>                    
        <span class="k">return</span> <span class="n">canMakeWordWalkRec</span><span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="n">word</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>                                                      
<span class="p">}</span>
</code></pre></div></div>
<p>This approach won‚Äôt try all possible words, since as soon as a word is found that overlaps with the previous word, we immediately return the result of the recursive call, even if that call failed. (This is like the shrinkable words example where we return too early ‚Äì we don‚Äôt consider all possible cases even though we need to.)</p>


</div>
</div>
<hr />

<h2 id="problem-eight-linear-probing-sleuthing">Problem Eight: Linear Probing Sleuthing</h2>

<p>In Assignment 7, you explored linear probing hash tables. In this problem, we will be exploring a linear probing table of integers. The hash code for each integer is formed by taking its last digit; for example, the hash code of 137 is 7, and the hash code of 106 is 6. Empty slots in the table are represented as blank spots, filled slots with the number they contain, and tombstones with the Â¢ì symbol.</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: center"><strong>18</strong></th>
      <th style="text-align: center"><strong>37</strong></th>
      <th style="text-align: center"><strong>Â¢ì</strong></th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center"><strong>95</strong></th>
      <th style="text-align: center"><strong>16</strong></th>
      <th style="text-align: center"><strong>5</strong></th>
      <th style="text-align: center"><strong>56</strong></th>
      <th style="text-align: center"><strong>39</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">[0]</td>
      <td style="text-align: center">[1]</td>
      <td style="text-align: center">[2]</td>
      <td style="text-align: center">[3]</td>
      <td style="text-align: center">[4]</td>
      <td style="text-align: center">[5]</td>
      <td style="text-align: center">[6]</td>
      <td style="text-align: center">[7]</td>
      <td style="text-align: center">[8]</td>
      <td style="text-align: center">[9]</td>
    </tr>
  </tbody>
</table>

<p>We filled this table in by starting with an empty table and using the standard linear probing algorithm from lecture without any modifications. The specific sequence of commands we issued to the table is shown below in the order in which those commands were performed. As you can see, some of the arguments to the commands have not been given.</p>

<p>Fill in the blanks such that executing the sequence of commands shown below builds the linear probing table shown above. As a hint, <em>you‚Äôll never need to insert something twice</em>, and <em>you‚Äôll never need to remove something that isn‚Äôt already in the table</em>. No justification is needed. Incorrect answers will not receive points, but otherwise there is no penalty for an incorrect guess.</p>

<ol>
  <li>Insert 28.</li>
  <li>Insert 32.</li>
  <li>Insert <strong>__</strong>.</li>
  <li>Remove <strong>__</strong>.</li>
  <li>Insert 18.</li>
  <li>Remove <strong>__</strong>.</li>
  <li>Insert 95.</li>
  <li>Insert <strong>__</strong>.</li>
  <li>Insert <strong>__</strong>.</li>
  <li>Insert <strong>__</strong>.</li>
  <li>Insert <strong>__</strong>.</li>
</ol>

<p>We recommend that you draw out an empty, ten-slot linear probing table like the one shown here for scratch work as you‚Äôre working through this problem.</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">¬†</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">[0]</td>
      <td style="text-align: center">[1]</td>
      <td style="text-align: center">[2]</td>
      <td style="text-align: center">[3]</td>
      <td style="text-align: center">[4]</td>
      <td style="text-align: center">[5]</td>
      <td style="text-align: center">[6]</td>
      <td style="text-align: center">[7]</td>
      <td style="text-align: center">[8]</td>
      <td style="text-align: center">[9]</td>
    </tr>
  </tbody>
</table>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-10" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-10">
   
<ol>
  <li>Insert 28.</li>
  <li>Insert 32.</li>
  <li>Insert <strong>39</strong>.</li>
  <li>Remove <strong>32</strong>.</li>
  <li>Insert 18.</li>
  <li>Remove <strong>28</strong>.</li>
  <li>Insert 95.</li>
  <li>Insert <strong>16</strong>.</li>
  <li>Insert <strong>5</strong>.</li>
  <li>Insert <strong>56</strong>.</li>
  <li>Insert <strong>37</strong>.</li>
</ol>

<p>To see where this comes from, let‚Äôs begin with item (iii). We see that, in step (v), we insert 18, and that element ends up at slot 0. The only way that can happen is if slots 8 and 9 are filled in, and so the only item we can insert that would end up in slot 9 is 39.</p>

<p>In step (iv), we can similarly reason by a process of elimination. The only elements we could remove would be 32 and 28, since neither end up in the finished table. If we removed 28, then when we inserted 18 it would overwrite the tombstone rather than ending up in slot 0. Therefore, we had to have removed 32. That then means step (vi) must have been to remove 28, since 28 doesn‚Äôt appear in the final table.</p>

<p>At the point at which we begin doing the insertions for steps (viii) and onward, we know that we have to insert 37, 16, 5, and 56 in some order, since they‚Äôre the only elements not yet in the table. So what order do they go in? If we insert 37 now, it‚Äôll end up in slot 7, which is the wrong place. Inserting 16 places it in the right place. Inserting 5 would put it into slot 6 (the wrong place), and inserting 56 would put it into slot 6 as well (also wrong). That means 16 has to go first.</p>

<p>Once we‚Äôve done that, we‚Äôre left with 37, 5, and 56 to insert. Inserting 37 still will put 37 in the wrong place ‚Äì for it to end up in slot 0, slots 7, 8, and 9 have to be filled first. If we insert 56 before 5, it‚Äôll end up in the wrong slot. So that means we have to insert 5 to fill slot 6, then 56 to fill slot 7, and finally 37 to fill slot 0.</p>

<p><strong><em>Why we asked this question</em></strong>: This question was designed to assess two different skills. The first was your comfort with the operation of linear probing hash tables. The second was your debugging skills. This question, essentially, presents you with the internal representation of a data structure and then asks you to work out how it arose.</p>


</div>
</div>
<hr />

<h2 id="problem-nine-complementary-strands">Problem Nine: Complementary Strands</h2>
<p>In Assignment 7, you explored how to encode DNA as linked lists of nucleotides. In humans, DNA strands are always paired with a <strong>complementary strand</strong>. This is a new strand of DNA linked alongside the original strand, except with different nucleotides. Specifically, any time there‚Äôs an A in the initial strand there‚Äôs a T in the complementary strand, and any time there‚Äôs a C in the initial strand there‚Äôs a G in the complementary strand (and vice-versa). Here‚Äôs an example of what this might look like:
<img src="img/complementary_strands.png" alt="Two strings of nucleotides, each represented as a doubly linked list. Each nucleotide in the top string is doubly linked to the nucleotide at the same position in the bottom string. The top string starts with G T C and the bottom string starts with C A G." /></p>

<p>We can represent a double-stranded DNA sequence as a modified doubly-linked list of nucleotides, where each nucleotide links to the nucleotides before and after it in the sequence, as well as to the nucleotide across from it:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Nucleotide</span> <span class="p">{</span>                                         
    <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>         <span class="c1">// 'A', 'C', 'G', or 'T'           </span>
    <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>   <span class="c1">// To the right                    </span>
    <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>   <span class="c1">// To the left                     </span>
    <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">across</span><span class="p">;</span> <span class="c1">// Vertically, to the other strand.</span>
<span class="p">};</span>                                                          
</code></pre></div></div>

<p>For example, in the picture shown above, the nucleotide G in the upper-left corner would have its <code class="language-c++ highlighter-rouge"><span class="n">prev</span></code> pointer set to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>, its next pointer set to the T nucleotide next to it, and its across pointer set to the C beneath it. The C nucleotide beneath it would have its next pointer set to the A to its right, its <code class="language-c++ highlighter-rouge"><span class="n">prev</span></code> pointer set to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code>, and its across pointer back to the G in the top strand.</p>

<p>Your task is to finish writing a function that works as follows. The function takes as input a single strand of DNA whose across pointers have not been initialized. The function then constructs the complementary strand, then links the two strands together by appropriately wiring the across pointers of the two strands.</p>

<p>Here is the implementation we‚Äôve provided to you. As indicated by the comment, your task is to fill in the contents of the while loop. You must not add, remove, or edit the code outside the body of the while loop.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="nf">complementOf</span><span class="p">(</span><span class="kt">char</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'A'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'T'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'C'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'G'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'G'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'C'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'T'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"Unknown nucleotide."</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">addComplementaryStrand</span><span class="p">(</span><span class="n">Nucleotide</span><span class="o">*</span> <span class="n">dna</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">dna</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* TODO: Add your code here! */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Some notes on this problem:</p>
<ul>
  <li>The <code class="language-c++ highlighter-rouge"><span class="n">across</span></code> pointers of each of the nucleotides in the input sequence have not been initialized when this function is called. You should not assume anything about where they point.</li>
  <li>For full credit, your solution must run in time <em>O(n)</em>, where <em>n</em> is the number of nucleotides in <code class="language-c++ highlighter-rouge"><span class="n">dna</span></code>.</li>
  <li>The input pointer will always point to the first nucleotide in the strand, or will be <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code> if the input DNA strand is empty.</li>
  <li>You can assume all letters in the DNA strand are either A, C, G, or T.</li>
  <li>You <strong><em>may not</em></strong> use any container types (e.g. <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code>, etc.) in the course of solving this problem. This includes the <code class="language-c++ highlighter-rouge"><span class="n">string</span></code> type.</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-11" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-11">
   
<p>There are several options here. Here‚Äôs one:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="nf">complementOf</span><span class="p">(</span><span class="kt">char</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'A'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'T'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'C'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'G'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'G'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'C'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="sc">'T'</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"Unknown nucleotide."</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">addComplementaryStrand</span><span class="p">(</span><span class="n">Nucleotide</span><span class="o">*</span> <span class="n">dna</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">dna</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Nucleotide</span><span class="o">*</span> <span class="n">partner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Nucleotide</span><span class="p">;</span>

        <span class="cm">/* Set the value. */</span>
        <span class="n">parnter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">complementOf</span><span class="p">(</span><span class="n">dna</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>

        <span class="cm">/* Wire the across pointers. */</span>
        <span class="n">dna</span><span class="o">-&gt;</span><span class="n">across</span> <span class="o">=</span> <span class="n">partner</span><span class="p">;</span>
        <span class="n">partner</span><span class="o">-&gt;</span><span class="n">across</span> <span class="o">=</span> <span class="n">dna</span><span class="p">;</span>

        <span class="cm">/* As of now, this cell has no next pointer, since we haven't built the
         * next cell yet.
         */</span>
        <span class="n">partner</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="cm">/* There may be a previous cell, though. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dna</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">partner</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dna</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">across</span><span class="p">;</span>
            <span class="n">dna</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">across</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">partner</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">partner</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Walk forward to the next cell. */</span>
        <span class="n">dna</span> <span class="o">=</span> <span class="n">dna</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question:</em></strong> This question was designed to see if you were comfortable with a few different aspects of linked list management: how to traverse a linked list forward, how to create new cells, how to link into a doubly-linked list, etc. There are a good number of moving parts here, but fortunately most of them are independent of all the others.</p>

<p><strong><em>Common mistakes:</em></strong> One of the most common mistakes we saw on this problem was misinterpreting the statement
‚ÄúThe function takes as input a single strand of DNA whose across pointers have not been initialized.‚Äù</p>

<p>This statement is meant to be taken literally. You are given a single DNA strand, and the across pointers have not been initialized. Many of you interpreted this to mean that the across pointers have been initialized to point to new <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code> objects, but those objects haven‚Äôt been initialized. That‚Äôs a different scenario than the one presented. In that case, all the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code>s are there, and all you have to do is link them. In the situation we wanted you to work through, you only have half the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code>s you need, and you need to create and then link the <code class="language-c++ highlighter-rouge"><span class="n">Nucleotide</span></code>s used in the other strand.</p>

<p>We also saw many solutions that ran into trouble with scoping issues. Many of you tried solving this problem by maintaining a pointer to the most-recently-constructed nucleotide, which you could then use to wire the nucleotides together more easily. However, because in this problem we constrained you to only write code inside the body of the while loop, this approach can‚Äôt be made to work because any local variables you‚Äôd made inside that loop would get reset on each loop iteration.</p>

<p>There were a couple of off-by-one errors where, on each iteration of the loop, the solution would create a nucleotide to pair with the current nucleotide, as well as a second one for its next pointer. This usually led to off-by-one errors where the resulting list would have too many nucleotides, though sometimes only in edge cases.</p>

</div>
</div>
<hr />

<h2 id="problem-ten-huffman-sleuthing">Problem Ten: Huffman Sleuthing</h2>
<p>Oops! We used the Huffman coding algorithm from Assignment 8 to determine codes for a bunch of characters, but we forgot the encoding of the character G.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Character</th>
      <th style="text-align: center">Encoding</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">A</td>
      <td style="text-align: center">1010</td>
    </tr>
    <tr>
      <td style="text-align: center">B</td>
      <td style="text-align: center">110</td>
    </tr>
    <tr>
      <td style="text-align: center">C</td>
      <td style="text-align: center">100</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">11101</td>
    </tr>
    <tr>
      <td style="text-align: center">E</td>
      <td style="text-align: center">1111</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">G</td>
      <td style="text-align: center"><code class="language-c++ highlighter-rouge"><span class="err">¬Ø\</span><span class="n">_</span><span class="p">(</span><span class="err">„ÉÑ</span><span class="p">)</span><span class="n">_</span><span class="o">/</span><span class="err">¬Ø</span></code></td>
    </tr>
    <tr>
      <td style="text-align: center">H</td>
      <td style="text-align: center">11100</td>
    </tr>
  </tbody>
</table>

<p>Your task is to help us figure out what the code for G is.</p>

<p>To do so, grab a sheet of scratch paper and draw as much of the Huffman coding tree as you can given the codes shown above. Once you‚Äôve done so, look over that tree and see if anything about it looks unusual. That will let you determine what the code for G is.</p>

<p>Code for G: <strong>__</strong><strong>__</strong><strong>__</strong>_</p>

<p>(No justification is needed. Incorrect answers will not receive points, but otherwise there is no penalty for an incorrect guess.)</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-12" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-12">
   
<p>Code for G: <strong><em>1011</em></strong>.</p>

<p>To see where this comes from, here‚Äôs the partial Huffman tree that results from these codes:
<img src="img/huffman.png" alt="A partial Huffman tree; all pointers to left children are labelled with a 0 and all pointers to right children are labelled with a 1. We will refer to left and right children as child 0 and child 1 respectively. Root node has child 0 f and non-terminal node as child 1. This node (one degree from root) has two children, both non-terminal nodes. Child 0 (two degrees down from root node) has child 0 C and child 1 non-terminal node. Child 1 of this node, which is now three degrees away from the root node, has child 0 A and child 1 G. Child 1 of the non-terminal node one degree away from root has two children, child 0 B and a non-terminal child 1 node (two degrees away from root). The non-terminal node has two children, a non-terminal child 0 (three degrees from root) and child 1 E. The non-terminal node (four degrees away from root) has child 0 H and child 1 D." /></p>

<p>We can tell that G has to go in the indicated spot for a few reasons:</p>
<ul>
  <li>In a coding tree, all the letters have to go in the leaves. This is the only spot we can add a leaf.</li>
  <li>In a Huffman tree, each node either has no children or exactly two children. Therefore, the node in the tree that has one child must really have two children, with the missing child being G.</li>
  <li>A Huffman tree is optimal. If G didn‚Äôt go here, then we could improve the code for A by putting A in its parent rather than its current spot.</li>
</ul>

<p>Why we asked this question: This question was designed to see if you‚Äôd built an intuition for Huffman coding and what sorts of trees come back beyond the mechanics of how to actually build one. We hoped that you be able to get the tree shown above from the codes, and from there to work out where G would have to go by using one of the above lines of reasoning (or another one we didn‚Äôt think of!)</p>

</div>
</div>
<hr />

<h2 id="problem-eleven-inflating-trees">Problem Eleven: Inflating Trees</h2>
<p>Consider the following type representing a node in a binary tree (though not necessarily a binary <em>search</em> tree):</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>   
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>  
    <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">};</span>              
</code></pre></div></div>

<p>Given a binary tree represented this way, we can <strong><em>inflate</em></strong> the binary tree by replacing all null pointers that appear in the original tree with new nodes, where each node‚Äôs value is the sum of the integers on the path from the root of the tree to that node. (One edge case: if the tree is empty, we replace the root with a new node whose value is zero). For example, here‚Äôs some sample trees and the result of inflating each of them. We‚Äôve explicitly drawn in the null left and right pointers on the initial trees to make the transformation clearer. Although the null pointers aren‚Äôt drawn in on the trees to the right, they are still present.
<img src="img/inflate.png" alt="Three examples of inflating binary trees. In the first example, the root node with value 1 has only a left child with value 3. After `inflate`, the root node with value 1 has a left child with value 3, which has left and right children of value 4 (the sum of 1 + 3). The root node with value 1 also has a right child of value 1. In the second example, the root node has value 6 and it has a left child with value -3 and a right child with value 4. After `inflate`, the root node has value 6, the left and right child are still -3 and 4 respectively, but each child now has two children -- both children of the root node's left child (value -3) have value 3, and both children of the root node's right child (value 4) have value 10. In the third example, we have an empty binary tree with no root node (the tree is just a nullptr). After `inflate`, the empty tree becomes a single node with value 0." /></p>

<p>Write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inflate</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">root</span><span class="p">);</span>
</code></pre></div></div>
<p>that takes as input a pointer to the root of a tree (or to <code class="language-c++ highlighter-rouge"><span class="nb">nullptr</span></code> if the tree is empty), then inflates the tree. Some notes:</p>
<ul>
  <li>Your solution does not have to be as efficient as possible, but you should avoid any unnecessary inefficiencies in your solution.</li>
  <li>You may not use any container types (e.g. <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code>, etc.) in the course of solving this problem.</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-13" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-13">
   
<p>Here‚Äôs one possibility. This works by passing the sum of all the numbers encountered so far down the recursion until we hit a null pointer:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inflate</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">inflateRec</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">inflateRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pathSum</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base case: If we hit null, replace it with the path sum. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span> <span class="n">pathSum</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="cm">/* Recursive case: inflate all nulls in the left and right subtrees, taking
     * the current node's value into account.
     */</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">inflateRec</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">pathSum</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="n">inflateRec</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">pathSum</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Why we asked this question: This question was designed to look at two different skills. First, there‚Äôs the question of how to move information around recursive calls. Here, we need to remember the sum of all the numbers above us at each point in time, and so we have a second parameter that tracks this bit, which we update with each call. Second, we have to walk the whole tree, which we do with the branching recursive call. As you can see, you don‚Äôt need all that much code here. The real challenge is figuring out how to walk up and down the tree passing the right information around.</p>

</div>
</div>
<hr />

<h2 id="problem-twelve-random-bag-lists">Problem Twelve: Random Bag Lists</h2>
<p>On Assignment 6 and Assignment 7, you gained experience writing classes that worked with dynamically-allocated memory. Assignment 8 also specifically asked you to work with doubly-linked lists. This question will ask you to implement another data structure with a doubly-linked list.</p>

<p>The very first class we designed in CS106B was the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code>. If you‚Äôll recall, the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code> supported two operations:</p>
<ul>
  <li><code class="language-c++ highlighter-rouge"><span class="n">add</span></code>, which adds an element to the random bag, and</li>
  <li><code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code>, which removes and returns a random element out of the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code>.</li>
</ul>

<p>When we first implemented <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code>, we layered it on top of the <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code> type. We‚Äôd like you to now go and reimplement <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code>, layered on top of a <strong><em>doubly-linked</em></strong> list.</p>

<p>For simplicity, we‚Äôve only asked you to implement the constructor, <code class="language-c++ highlighter-rouge"><span class="n">add</span></code>, and <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code>. You don‚Äôt need to implement a destructor or any other member functions. You‚Äôre welcome to add new member functions and data members if you‚Äôd like.
Your implementation of <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code> should have an equal probability of returning any of the elements currently stored in the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code> and should not leak any memory. Additionally, <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code> should call error, with whatever error message you think is most amusing, if the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code> is empty.</p>

<p>Feel free to use this function to generate random numbers:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">randomInteger</span><span class="p">(</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">);</span> <span class="c1">// Between low and high, inclusive</span>
</code></pre></div></div>

<p>To receive full credit on this problem, you should not use any of the standard container types (<code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Map</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">Set</span></code>, etc.) in your solution, since the purpose of this problem is for you to implement a custom type without layering on top of an existing container.</p>

<p>For full credit, your implementation of add should run in time O(1) and your implementation of <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code> should run in time O(n), where n is the number of elements in the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span></code>.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-14" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-14">
   
<p>There are several ways to code this up. Here‚Äôs an initial version, which uses a doubly-linked list that doesn‚Äôt have any dummy cells:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/****** RandomBag.h ******/</span>
<span class="k">class</span> <span class="nc">RandomBag</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">RandomBag</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">int</span>  <span class="n">removeRandom</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Cell</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">Cell</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">Cell</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Cell</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numElems</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/****** RandomBag.cpp ******/</span>
<span class="cp">#include "RandomBag.h"
#include "random.h"
#include "error.h"
</span>
<span class="cm">/* Constructor just sets things up so that everything is empty. */</span>
<span class="n">RandomBag</span><span class="o">::</span><span class="n">RandomBag</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">numElems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add prepends an element to the front of the list. */</span>
<span class="kt">void</span> <span class="n">RandomBag</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">cell</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="cm">/* Update the head to point back to us. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>

    <span class="cm">/* Either way, we're at the front of the list. */</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>

    <span class="n">numElems</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove chooses and removes a single element. */</span>
<span class="kt">int</span> <span class="n">RandomBag</span><span class="o">::</span><span class="n">removeRandom</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numElems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">error</span><span class="p">(</span><span class="s">"Such things are not to be found in the void."</span><span class="p">);</span>

    <span class="cm">/* Choose the element to remove. */</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">randomInteger</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numElems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* Find that element. */</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">toRemove</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Splice that cell out of the list. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

    <span class="cm">/* We may be the head of the list. If so, go update that. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">toRemove</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="n">head</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

    <span class="cm">/* Update element count so we know how many items exist. */</span>
    <span class="n">numElems</span><span class="o">--</span><span class="p">;</span>

    <span class="cm">/* Deallocate the memory for this cell. */</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">toRemove</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs an alternative that uses a dummy head and tail cell. This one also doesn‚Äôt explicitly keep track of how many cells are in the list, requiring two passes to do a <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code>.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/****** RandomBag.h ******/</span>
<span class="k">class</span> <span class="nc">RandomBag</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">RandomBag</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">int</span>  <span class="n">removeRandom</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Cell</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">Cell</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">Cell</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Cell</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">numElems</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/****** RandomBag.cpp ******/</span>
<span class="cp">#include "RandomBag.h"
#include "random.h"
#include "error.h"
</span>
<span class="cm">/* Create a dummy head and tail cell. */</span>
<span class="n">RandomBag</span><span class="o">::</span><span class="n">RandomBag</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="p">;</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="p">;</span>

    <span class="cm">/* They point to each other. */</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="cm">/* They demarcate the bounds. */</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Add prepends an element to the front of the list. */</span>
<span class="kt">void</span> <span class="n">RandomBag</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">cell</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="cm">/* Splice this into the list. */</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>

    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove chooses and removes a single element. */</span>
<span class="kt">int</span> <span class="n">RandomBag</span><span class="o">::</span><span class="n">removeRandom</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">tail</span><span class="p">)</span> <span class="n">error</span><span class="p">(</span><span class="s">"Cannot create values ex nihilo."</span><span class="p">);</span>

    <span class="cm">/* Choose the element to remove. */</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">randomInteger</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numElems</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* Find that element. */</span>
    <span class="n">Cell</span><span class="o">*</span> <span class="n">toRemove</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">toRemove</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Splice that cell out of the list. */</span>
    <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

    <span class="cm">/* Deallocate the memory for this cell. */</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">toRemove</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">toRemove</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Counts the number of (non-dummy) cells in the list. */</span>
<span class="kt">int</span> <span class="n">RandomBag</span><span class="o">::</span><span class="n">numElems</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Cell</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">curr</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">;</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question:</em></strong> We included this question for a number of reasons. First, we wanted to let you show us what you‚Äôd learned about defining an implementing a class backed by dynamic memory. Do you need a head pointer or a tail pointer? Do you need dummy elements? These decisions are all worth pondering, and we hoped you‚Äôd think through them while working on this problem.</p>

<p>Second, we wanted to give you practice traversing linked lists (here, to find an element to remove), one of the major list operations. Third, we wanted to see how you‚Äôd handle boundary cases like removing from a list when there‚Äôs only a single element or inserting into an otherwise empty list.</p>

<p>Finally, wanted to see how well you‚Äôd internalized pointer manipulation techniques and memory management. Given that <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code> isn‚Äôt supposed to leak memory, which cells, specifically, need to be reclaimed? How do you sequence that memory cleanup along with the other operations?</p>

<p><strong><em>Common mistakes:</em></strong> Many of the issues we saw people run into on this problem stemmed from simple, run-of-the-mill pointer mistakes. Some solutions forgot to account for the case where the list was empty or had just a single element, accidentally reading or writing null pointers. Others didn‚Äôt do all the proper linked list wiring (for example, forgetting to set one of the previous pointers of a linked list cell). Some solutions used dummy nodes but forgot not to count them when determining which node to select. Many answers forgot to deallocate the removed cell, or deallocated the cell and then tried reading its contents.</p>

<p>Other issues we encountered seemed to stem from a misunderstanding of what was being asked. Some solutions treated the <code class="language-c++ highlighter-rouge"><span class="n">RandomBag</span><span class="o">::</span><span class="n">add</span></code> function‚Äôs value parameter as a number of random elements to add to the random bag rather than as a specific value that was supposed to be stored. Other solutions didn‚Äôt attempt to remove anything in <code class="language-c++ highlighter-rouge"><span class="n">removeRandom</span></code>. A few solutions used a singly-linked list rather than a doubly-linked list (oops).</p>

<p>Some solutions came up with options that technically worked but which were highly inefficient. For example, some solutions would generate a random number representing a value to remove, then iterate over the list to see whether it was there. If this didn‚Äôt work, they‚Äôd repeat this process. While this technically works, it‚Äôs likely going to take a long time to remove an element from the random bag if, say, there‚Äôs just a single element in the list.</p>

</div>
</div>
<hr />

<h2 id="problem-thirteen-agglomerative-clustering">Problem Thirteen: Agglomerative Clustering</h2>
<p>A <strong><em>full binary tree</em></strong> is a binary tree where each node either has two children or no children. Here are some sample full binary trees:
<img src="img/full_binary_tree.png" alt="Three examples of full binary trees. The first has a root node with value 271 which has left and right children with values 314 and 161 respectively. The left child has two children, left and right with values 42 and 106 respectively, and the right child of the root node has no children. The second example has a root node of value 1 and left and right children with values 2 and 3 respectively. The third example has a root node with value 137 with no children." /></p>

<p>Note that full binary trees are not necessarily binary <em>search</em> trees.</p>

<p>Let‚Äôs imagine that we have a type representing a node in a full binary tree, which is shown here:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>                                               
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>  <span class="c1">// The value stored in this node         </span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>    <span class="c1">// Standard left and right child pointers</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>                                            
<span class="p">};</span>                                                          
</code></pre></div></div>

<p>Your first task in this problem is to write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">leavesOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">);</span>
</code></pre></div></div>
<p>that takes as input a pointer to the root of a full binary tree, then returns a set of all the values stored in the leaves of that tree. For example, calling this function on the leftmost tree above would return a set containing {42, 106, 161}, calling this function on the tree in the middle would return {2, 3}, and calling this function on the tree on the right would return {137}.</p>

<p>Some notes:</p>
<ul>
  <li>You can assume that the pointer to the root of the tree is not null.</li>
  <li>You should completely ignore the values stored at the intermediary nodes.</li>
</ul>

<p>The second part of this problem explores an algorithm called <strong><em>agglomerative clustering</em></strong> that, given a collection of data points, groups similar data points together into clusters of similar values. The algorithm works by starting with a bunch of singleton nodes and assembling them into full binary trees. For the purposes of this problem, we‚Äôll cluster a group of doubles.</p>

<p>The first step in running agglomerative clustering is to create singleton trees for each of the data points. For example, given the numbers 1, 6, 8, 18, 33, and 37, we‚Äôd begin with the following trees:
<img src="img/agglomerative_1.png" alt="6 singleton trees (root node with no children), with values 1, 6, 8, 18, 33, 37." /></p>

<p>We now choose the two trees whose root nodes‚Äô values are closest to one another. Here, we pick the trees holding 6 and 8. We then merge those two trees into a single tree, and give the root of the new tree the average value of all its leaves. Here, the leaves hold 6 and 8, so the new tree has root value 7:
<img src="img/agglomerative_2.png" alt="5 trees -- singleton with value 1, tree with root node 7 with 2 children, 6 and 8 for left and right respectively, and three more singleton trees with values 18, 33, 37." /></p>

<p>We repeat this process, again selecting the two trees whose root values are as close as possible. In this case, that would be 33 and 37, which get merged into a new tree:
<img src="img/agglomerative_3.png" alt="4 binary trees -- singleton with value 1, same tree as above with root node 7 and children 6 and 8, singleton with value 18, and tree with root node 35 and left and right children 33 and 37 respectively." />
Notice that the new root node has the value 35, the average value of its leaves.</p>

<p>On this next step, we‚Äôll find that the trees with the two closest roots are the ones with roots 1 and 7. We merge those trees into a new tree. As before, the root of this tree is then assigned the average value of all its leaves. The leaves have values 1, 6, and 8, so the new root gets the value 5. Here‚Äôs the result:
<img src="img/agglomerative_4.png" alt="Three trees. The first has root node 5 which has children 1 and 7. Right child of 7 has left and right children 6 and 8. The second tree is a singleton tree with value 18. The third tree has a root node 35 with left and right children 33 and 37 respectively." /></p>

<p>Each step in this process reduces the number of trees by one. We‚Äôll stop this algorithm once we‚Äôve reduced things down to a small number of trees; how many trees, exactly, we‚Äôll leave as a parameter for the user to specify.</p>

<p>If we stop here, we have three clusters: the cluster {1, 6, 8}, the cluster {18}, and the cluster {33, 37}, which you can see by looking at the leaves of the resulting trees.</p>

<p>Write a function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">cluster</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numClusters</span><span class="p">);</span>
</code></pre></div></div>
<p>that takes as input a set of values and a desired number of clusters, then runs the agglomerative clustering algorithm described on the previous page to form the specified number of clusters. This function should then return a <code class="language-c++ highlighter-rouge"><span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span></code> containing pointers to the roots of the trees formed this way. Some notes:</p>
<ul>
  <li>You can assume the number of clusters is less than or equal to the number of values and greater than or equal to one (the algorithm only works on values in those ranges).</li>
  <li>If there‚Äôs a tie between which pair of tree roots is closest, break the tie however you‚Äôd like.</li>
  <li>You‚Äôll almost certainly want to use the <code class="language-c++ highlighter-rouge"><span class="n">leavesOf</span></code> function you wrote in the first part of this function in the course of writing up your solution.</li>
</ul>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-15" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-15">
   
<p>There are many ways to implement the leavesOf function. The first solution works by returning values upward through the recursion, and the second solution works by filling an outparameter:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">leavesOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Base Case: The set of values in a leaf node is just the one value here. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span> <span class="p">};</span>

    <span class="cm">/* Recursive Step: Combine the sets from the left and right subtrees. */</span>
    <span class="k">return</span> <span class="n">leavesOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">leavesOf</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">leavesOf</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">leavesOfRec</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">leavesOfRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">leavesOfRec</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">result</span><span class="p">);</span>
        <span class="n">leavesOfRec</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs one possible implementation of the clustering code:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Helper struct representing a pair of nodes. */</span>
<span class="k">struct</span> <span class="nc">NodePair</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">cluster</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numClusters</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">trees</span> <span class="o">=</span> <span class="n">makeSingletons</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>

    <span class="cm">/* Keep merging trees until we have the specified number required. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">trees</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">numClusters</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Find the closest pair of trees. */</span>
        <span class="n">NodePair</span> <span class="n">closest</span> <span class="o">=</span> <span class="n">closestTreesIn</span><span class="p">(</span><span class="n">trees</span><span class="p">);</span>

        <span class="cm">/* Merge them together. */</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">root</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">closest</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">closest</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">averageOf</span><span class="p">(</span><span class="n">leavesOf</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

        <span class="cm">/* Remove the old trees from the set. */</span>
        <span class="n">trees</span> <span class="o">-=</span> <span class="n">closest</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="n">trees</span> <span class="o">-=</span> <span class="n">closest</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

        <span class="cm">/* Add in this new tree. */</span>
        <span class="n">trees</span> <span class="o">+=</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">trees</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Computes the average of a set of doubles. */</span>
<span class="kt">double</span> <span class="nf">averageOf</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">value</span><span class="o">:</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Given a set of values, forms a set of singleton trees from those values. */</span>
<span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">makeSingletons</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">elems</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="o">:</span> <span class="n">elems</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">singleton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
        <span class="n">singleton</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">singleton</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">singleton</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">singleton</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Given a pair of doubles, returns the distance between them. */</span>
<span class="kt">double</span> <span class="nf">distance</span><span class="p">(</span><span class="kt">double</span> <span class="n">one</span><span class="p">,</span> <span class="kt">double</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Distance is the absolute value of their difference. */</span>
    <span class="k">return</span> <span class="n">fabs</span><span class="p">(</span><span class="n">one</span> <span class="o">-</span> <span class="n">two</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Given a set of trees, returns the two trees with the closest roots. */</span>
<span class="n">NodePair</span> <span class="nf">closestTreesIn</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;&amp;</span> <span class="n">trees</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodePair</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">bestDistance</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">one</span><span class="o">:</span> <span class="n">trees</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">two</span><span class="o">:</span> <span class="n">trees</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">one</span> <span class="o">!=</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Don‚Äôt merge a tree with itself!</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">one</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">two</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bestDistance</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">one</span><span class="p">;</span>
                    <span class="n">result</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">two</span><span class="p">;</span>
                    <span class="n">bestDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">one</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">two</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong><em>Why we asked this question:</em></strong> As the title suggests, this question was designed to see how comfortable you‚Äôve become working with trees and tree structures. The first part of this problem was a tree recursion problem to make sure you were comfortable with the idea of exploring all the nodes in a tree. The second part of this problem (for which I have to give credit to Chris Piech for the concept) was designed to let you demonstrate what you‚Äôd learned about bottom-up tree assembly. We hoped that the core idea ‚Äì find two close trees, merge them, repeat ‚Äì would let you show what you‚Äôd learned about collections of tree nodes, assembling trees bottom-up, and reporting multiple values across different function calls.</p>

<p>It turns out that with the right data structures you can implement this algorithm so that it runs in time O(n log n). Take CS166 if you‚Äôre curious how to do this!</p>

</div>
</div>
<hr />

<h2 id="problem-fourteen-rainwater-collection">Problem Fourteen: Rainwater Collection</h2>
<p>You are interested in setting up a collection point to funnel rainwater into a town's water supply. The town is next to a ridge, which for simplicity we will assume is represented as an array of the elevations of different points along the ridge.
When rain falls on the ridge, it will roll downhill along the ridge. We'll call a point where water naturally accumulates (that is, a point lower than all neighboring points) a ‚Äúgood collection point.‚Äù For example, here is a possible ridge with good collection points identified:
<img src="img/rainwater14.png" alt="A ridge for the raindrop to roll on. There are 11 heights on the ridge: 11, 8, 4, 2, 5, 3, 12, 10, 14, 15, 6." />
Write a recursive function</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">goodCollectionPointFor</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="p">);</span>
</code></pre></div></div>
<p>that returns the index of a good collection point. Your solution should run in time O(log <em>n</em>). As a hint, think about binary search. You can assume that all elements in the array are distinct.
‚Äã</p>
<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-16" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-16">
   
<p>‚Äã
The key insight here is to look at the two middle elements of the array to see which direction they slope downhill. Imagine that the water would flow to the left. Then, if we look in the first half of the array, we know there has to be a good collection point somewhere to the left, since if the water flows downhill it has to collect somewhere over there. Using this insight, we can modify our binary search to look like this:
‚Äã</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Given an index into the ridge, returns whether the given index is a good
 * collection point. That happens if both of the position's neighbors are higher
 * than the position itself.
 */</span>
<span class="kt">bool</span> <span class="nf">isGoodPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Handle boundary cases by pretending the boundaries are infinitely high. */</span>
  <span class="kt">double</span> <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="o">?</span> <span class="n">INFINITY</span> <span class="o">:</span> <span class="n">heights</span><span class="p">[</span><span class="n">index</span> <span class="err">‚Äì</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="kt">double</span> <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">heights</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">?</span> <span class="n">INFINITY</span><span class="o">:</span> <span class="n">heights</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">heights</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Return the index of a good collection point in the interval [start, end). Note
 * that start is inclusive and that end is exclusive.
 */</span>
<span class="kt">int</span> <span class="nf">goodCollectionPointRec</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Base case: If the midpoint is a collection point, we're done. */</span>
  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="err">‚Äì</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isGoodPoint</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">mid</span><span class="p">))</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
<span class="err">‚Äã</span>
  <span class="cm">/* If we are on a downward facing slope (left is greater than curr)
  * then search to the right of here
  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">heights</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heights</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">goodCollectionPointRec</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
  <span class="p">}</span>
<span class="err">‚Äã</span>
  <span class="cm">/* Otherwise we are on upward facing slope; collection point is to the left
  * so we can limit our search to the left range.
  */</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">goodCollectionPointRec</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">goodCollectionPointFor</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">heights</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">goodCollectionPointRec</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">heights</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p><em>(Thanks to legendary SL Ali Malik for this code!)</em>
‚Äã</p>

</div>
</div>
<hr />

<p>‚Äã</p>
<h2 id="problem-fifteen-palindromic-trees">Problem Fifteen: Palindromic Trees</h2>
<p>‚Äã
A binary tree (not necessarily a binary <em>search tree</em>) is called a <strong>palindromic tree</strong> if it‚Äôs its own mirror image. For example, the tree on the left is a palindromic tree, but the tree on the right is not:
<img src="img/palindromeTree15.png" alt="The tree on the left is a palindromic tree. It looks like this: Node 3 on the first level, nodes 2 and 2 on the second level, nodes 5, 4 and 4, 5 on the third level, and nodes 1 &amp; 2 under the left-most node 4 and nodes 2&amp;1 under the right-most node 4. The tree on the right is not a palindromic tree. It looks like this: Node 3 on the first level, nodes 1 and 1 on the second level, nodes 1 &amp; 2 as the children of the left-most 1 node on the third level, and nodes 1 &amp; 2 as the children of the right-most node on the third level. " />
Write a function that takes in a pointer to the root of a binary tree and returns whether it‚Äôs a palindrome tree.
‚Äã</p>
<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-17" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-17">
   
<p>‚Äã
To solve this problem, we‚Äôll solve a slightly more general problem: given two trees, are they mirrors of one another? We can then check if a tree is a palindrome by seeing whether that tree is a mirror of itself.
‚Äã</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isPalindromicTree</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">areMirrors</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">areMirrors</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* If either tree is empty, both must be. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">root2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">root1</span> <span class="o">==</span> <span class="n">root2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="err">‚Äã</span>
  <span class="cm">/* Neither tree is empty. The roots must have equal values. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">!=</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="err">‚Äã</span>
  <span class="cm">/* To see if they're mirrors, we need to check whether the left subtree of
  * the first tree mirrors the right subtree of the second tree and vice-versa.
  */</span>
  <span class="k">return</span> <span class="n">areMirrors</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="n">areMirrors</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><em>(Thanks to legendary SL Ali Malik for this code!)</em>
‚Äã</p>

</div>
</div>
<hr />

<p>‚Äã</p>
<h2 id="problem-sixteen-the-great-tree-list-recursion-problem">Problem Sixteen: The Great Tree List Recursion Problem</h2>

<p><em>This excellent problem by Nick Parlante</em></p>

<p>‚Äã
A node a binary tree has the same fields as a node in a doubly-linked list: one field for some data and two pointers. The difference is what those pointers mean: in a binary tree, those fields point to a left and right subtree, and in a doubly-linked list they point to the next and previous elements of the list. Write a function that, given a pointer to the root of a binary <em>search</em> tree, flattens the tree into a doubly-linked list, with the values in sorted order, without allocating any new cells. You‚Äôll end up with a list where the pointer <code class="language-c++ highlighter-rouge"><span class="n">left</span></code> functions like the <code class="language-c++ highlighter-rouge"><span class="n">prev</span></code> pointer in a doubly-linked list and where the pointer <code class="language-c++ highlighter-rouge"><span class="n">right</span></code> functions like the next pointer in a doubly-linked list.
‚Äã</p>
<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-18" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-18">
   
<p>‚Äã
This is a beautiful recursion problem. Essentially, what we want to do is the following:</p>

<ul>
  <li>The empty tree is already indistinguishable from the empty list.</li>
  <li>Otherwise, flatten the left subtree and right subtree, then concatenate everything together.</li>
</ul>

<p>To implement that last step efficiently, we‚Äôll have our recursive function hand back two pointers: one to the front of the flattened list and one to the back.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Range</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">last</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Node</span><span class="o">*</span> <span class="nf">treeToList</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Range</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* If the tree is empty, it's already flattened. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
    
    <span class="cm">/* Flatten the left and right subtrees. */</span>
    <span class="n">Range</span> <span class="n">left</span>  <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">Range</span> <span class="n">right</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    
    <span class="cm">/* Glue things together. */</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">last</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">left</span><span class="p">.</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">right</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    
    <span class="cm">/* Return the full range. */</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="n">left</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">?</span> <span class="n">root</span> <span class="o">:</span> <span class="n">left</span><span class="p">.</span><span class="n">first</span><span class="p">,</span>
      <span class="n">right</span><span class="p">.</span><span class="n">last</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">?</span> <span class="n">root</span> <span class="o">:</span> <span class="n">right</span><span class="p">.</span><span class="n">last</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>


</div>
</div>
<hr />

<h2 id="problem-seventeen-changing-passwords">Problem Seventeen: Changing Passwords</h2>

<p>Looking to change your password? Rather than picking a password that‚Äôs a common word or phrase with a bunch of random numbers thrown in, consider using a multi-word password formed by choosing some sequence of totally random words out of the dictionary. Choosing four totally random words, it turns out, tends to be a pretty good way to make a password. Here‚Äôs a couple passwords you might make that way:</p>

<blockquote>
  <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  RantingCollegersDenoteClinching
  VivificationPandectYawnedCarmine
  DetachednessHowlinglySportscastsVapored
  UnlearnedMockeriesTuskedChuckles
  SharpshootingPreyParaffinsLibeler
</code></pre></div>  </div>
</blockquote>

<p>We generated these particular passwords using the following piece of code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">makeRandomPassword</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">wordList</span><span class="p">)</span> <span class="p">{</span> 
   <span class="n">string</span> <span class="n">result</span><span class="p">;</span>                                           
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>                            
      <span class="kt">int</span> <span class="n">wordIndex</span> <span class="o">=</span> <span class="n">randomInteger</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">wordList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">result</span> <span class="o">+=</span> <span class="n">wordList</span><span class="p">[</span><span class="n">wordIndex</span><span class="p">];</span>                        
   <span class="p">}</span>                                                        
   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>                                           
<span class="p">}</span>
</code></pre></div></div>

<p>When we ran this code, we used a word list containing about 120,000 words. There are other word lists available that we could have picked. The Basic English dictionary, for example, only has about 5,000 words. A more elaborate dictionary called ENABLE has about 180,000 words. It‚Äôs therefore not all that unreasonable for us to analyze the efficiency of the above code in terms of the number of words n in our word list.</p>

<ol class="pset-item-list" start="1"><li>
<p>Let $n$ denote the number of words in wordList. What is the big-O time complexity of the above code as a function of $n$? You can assume that the words are short enough that the cost of concatenating four strings together is O(1) and that a random number can be generated in time O(1). Explain how you arrived at your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-19" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-19">
   
<p>The cost of looking at the size of the <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code> is O(1) and the cost of reading any element it is O(1). We do four reads and call size four times. Each operation takes time O(1). Therefore, this code runs in time <strong>O(1)</strong>.</p>

</div>
</div>
<hr />

</li></ol>

<ol class="pset-item-list" start="2"><li>
<p>Let‚Äôs suppose that the above code takes 1ms to generate a password when given a word list of length 50,000. Based on your analysis from part (i), how long do you think the above code will take to generate a password when given a word list of length 100,000? Explain how you arrived at your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-20" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-20">
   
<p>Since the runtime is O(1), it‚Äôs independent of the size of the <code class="language-c++ highlighter-rouge"><span class="n">Vector</span></code>. Therefore, we‚Äôd expect that this code would take 1ms to complete in this case.</p>

</div>
</div>
<hr />

</li></ol>

<p>Now, let‚Äôs think about how someone might try to break your password. If they know that you chose four totally random English words, they could try logging in using every possible combination of four English words. Here‚Äôs some code that tries to do that:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">breakPassword</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">wordList</span><span class="p">)</span> <span class="p">{</span>                            
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wordList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>                                     
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">wordList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>                                   
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">wordList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>                                 
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">wordList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>                               
          <span class="n">string</span> <span class="n">password</span> <span class="o">=</span> <span class="n">wordList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">wordList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">wordList</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">wordList</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">passwordIsCorrect</span><span class="p">(</span><span class="n">password</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">password</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>                                                                         
      <span class="p">}</span>                                                                           
    <span class="p">}</span>                                                                             
  <span class="p">}</span>                                                                               
<span class="p">}</span>      
</code></pre></div></div>

<p>As before, let‚Äôs assume that the words in our word list are short enough that the cost of concatenating four of them together is O(1). Let‚Äôs also assume that calling the <code class="language-c++ highlighter-rouge"><span class="n">passwordIsCorrect</span></code> function with a given password takes time O(1).</p>

<ol class="pset-item-list" start="3"><li>
<p>What is the worst-case big-O time complexity of the above piece of code as a function of $n$, the number of words in the word list? Explain how you arrived at your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-21" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-21">
   
<p>Working from the inside out: the code inside the loop on <code class="language-c++ highlighter-rouge"><span class="n">l</span></code> does O(1) work. Each of the loops on <code class="language-c++ highlighter-rouge"><span class="n">i</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">j</span></code>, <code class="language-c++ highlighter-rouge"><span class="n">k</span></code>, and <code class="language-c++ highlighter-rouge"><span class="n">l</span></code> run $n$ times. Multiplying this together gives a runtime of O($n^4$).</p>

</div>
</div>
<hr />

</li></ol>

<ol class="pset-item-list" start="4"><li>
<p>Imagine that in the worst case it takes 1,000 years to break a four-word password when given a word list of length 50,000. Based on your analysis from part (iii), how long will it take, in the worst case, to break a password when given a word list of length 100,000? Explain how you arrived at your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-22" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-22">
   
<p>Since the runtime is O($n^4$), doubling the size of the input will increase the runtime by a factor of $2^4 = 16$. Therefore, we‚Äôd expect this would take 16,000 years to complete in the worst-case.</p>

</div>
</div>
<hr />

</li></ol>

<h2 id="problem-eighteen-social-network-scaling">Problem Eighteen: Social Network Scaling</h2>

<p>While most researchers agree that the value of a social network grows as the number of users grows, there‚Äôs significant debate about precisely how that value scales as a function of the number of users.</p>

<p>Suppose there‚Äôs a social network whose value, with its current number of users, is $10,000,000.</p>

<ol class="pset-item-list" start="1"><li>
<p><strong><em>Sarnoff‚Äôs Law</em></strong> states that the value of a network is O(n), where n is the number of users on the network. Assuming Sarnoff‚Äôs law is correct, estimate how much the social network needs to grow to have value $160,000,000. Justify your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-23" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-23">
   
<p>The network would need to grow to size roughly $16n$. Since the value of the network scales linearly, to get a 16√ó increase in value, you need roughly a 16√ó increase in size.</p>

</div>
</div>
<hr />

</li></ol>

<ol class="pset-item-list" start="2"><li>
<p><strong><em>Metcalfe‚Äôs Law</em></strong> states that the value of a network is O($n^2$), where n is the number of users on the network. Assuming Metcalfe‚Äôs law is correct, estimate how much the social network needs to grow to have value $160,000,000. Justify your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-24" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-24">
   
<p>The network would need to grow to size roughly $4n$. Since the value of the network scales quadratically, to get a 16√ó increase in value, you need roughly a 4√ó increase in size ($(4n)^2 = 16n^2$).</p>

</div>
</div>
<hr />

</li></ol>

<ol class="pset-item-list" start="3"><li>
<p><strong><em>Reed‚Äôs Law</em></strong> states that the value of a network is O($2^n$), where n is the number of users on the network. Assuming Reed‚Äôs law is correct, estimate how much the social network needs to grow to have value $160,000,000. Justify your answer. Your answer should be no more than 50 words long.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-25" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-25">
   
<p>The network would need to grow to size roughly $n + 4$. Note that $2^{n+4} = 2^n \cdot 2^4 = 16 \cdot 2^n$, so adding
four more people increases the value of the network by the needed factor of sixteen.</p>

</div>
</div>
<hr />

</li></ol>

<h2 id="problem-nineteen-graph-sleuthing">Problem Nineteen: Graph Sleuthing</h2>

<p>Consider the picture of the graph shown below:</p>

<blockquote>
  <p><img src="img/graph-sleuthing.png" alt="A graph with 12 nodes: X, C, V, A, L, Z, G, Q, R, K, H, and F. Node X is adjacent to nodes C and Q. Node C is adjacent to nodes X and V. Node V is adjacent to nodes C, A, and Q. Node A is adjacent to nodes V, L, and Z. Node L is adjacent to nodes A, Z, and G. Node Z is adjacent to nodes A, L, and G. Node G is adjacent to nodes L and Z. Node Q is adjacent to nodes X, V, and R. Node R is adjacent to nodes Q and K. Node K is adjacent to nodes R, H, and F. Node H is adjacent to nodes K and F. Node F is adjacent to nodes K and H" /></p>
</blockquote>

<p>Suppose we run a breadth-first search on this graph, starting at node X. Whenever we dequeue a node from the BFS queue, we print out that node‚Äôs label.</p>

<ol class="pset-item-list" start="1"><li>
<p>Explain why it is <strong><em>impossible</em></strong> to get back the following sequence of nodes when running BFS on the above graph, starting at node X.</p>

<blockquote>
  <p>X, Q, C, R, V, K, Z, A, F, H, L, G</p>
</blockquote>

<p>Please limit your answer to fifty words or fewer. As a hint, in what order does BFS visit nodes when exploring a graph?</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-26" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-26">
   
<p>There are many reasons why this sequence cannot be obtained. Here are a few:</p>

<p>‚ÄúWe should see the nodes in increasing order of distance. However, node Z is at distance 4 from the start node X, and it‚Äôs reported between nodes A and K, which are at distance 3 from the start node X, which is impossible.‚Äù</p>

<p>‚ÄúNode Z appears before node A in the ordering, but there‚Äôs no path that reaches node A without first going through node V.‚Äù</p>

<p>‚ÄúBFS cannot dequeue a node until one of its neighbors has first been dequeued. But Z appears before any of its neighbors appears, which breaks that rule.‚Äù</p>

</div>
</div>
<hr />

</li></ol>

<p>Now, a little more backstory. We did get the above sequence by running BFS on some graph. It just wasn‚Äôt the graph shown above. We‚Äôll call the graph that we ran BFS on the <strong><em>mystery graph</em></strong>.</p>

<p>The mystery graph is identical to the above graph except that one additional edge has been added in. That edge, which is an undirected edge, links two nodes that do not appear to be linked in the above diagram. We‚Äôll call that edge the <strong><em>mystery edge</em></strong>.</p>

<ol class="pset-item-list" start="2"><li>
<p>Based on the BFS traversal, the picture given above, and the fact that only one extra edge has been added in, you have enough information to narrow down the mystery edge to one of two possibilities. What are those two possibilities? No justification is required.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-27" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-27">
   
<p>The two options are {V, Z} and {R, Z}.</p>

<p>To see why, the only way this BFS ordering is possible is if Z is at distance 3 from X. Since Z is currently at distance 4 from X, we know that Z has to be one of the endpoints of the edge. The other endpoint of the edge has to be something that‚Äôs at distance 2 from X, which would correctly make node Z at distance 3. That limits our options to {V, Z} and {R, Z}.</p>

</div>
</div>
<hr />

</li></ol>

<p>One last piece of information about the mystery graph. We additionally ran a DFS on the mystery graph, also starting from the node X. That DFS was implemented recursively, and whenever we made a recursive call on a node for the very first time, we printed out the label on that node. Here‚Äôs the sequence of nodes we got back:</p>

<blockquote>
  <p>X, Q, R, K, F, H, Z, G, L, A, V, C</p>
</blockquote>

<p>Just to make sure that we‚Äôre clear about this, this is a DFS from the mystery graph, the one that has the extra edge added in relative to the above picture. The above sequence couldn‚Äôt be produced in the graph shown above.</p>

<ol class="pset-item-list" start="3"><li>
<p>Explain why it is impossible to get the above sequence of nodes as the result of DFS in the graph drawn above. Please limit your answer to fifty words or fewer.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-28" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-28">
   
<p>There are many ways to account for this. Here are a few:</p>

<p>‚ÄúAfter we visit node H, we should backtrack to the last node with a neighbor we haven‚Äôt yet seen. In the picture, that‚Äôs node Q, so we should have seen Q‚Äôs neighbor V after seeing H. But instead, we see Z.‚Äù</p>

<p>‚ÄúThis node ordering places A before V, but every path from X to A that passes through V first.‚Äù</p>

<p>‚ÄúNode Z can only appear in a DFS ordering if one of its neighbors appears before it in the ordering, and none of Z‚Äôs neighbors appear before it.‚Äù</p>

</div>
</div>
<hr />

</li></ol>

<ol class="pset-item-list" start="4"><li>
<p>You now have enough information to identify the mystery edge. Which edge is it, and why? Please limit your answer to fifty words or fewer.</p>

<div class="solution">
<div class="text-center">
<a class="btn btn-primary" data-toggle="collapse" href="index.html#solution-collapse-29" role="button">Solution</a>
</div>
<div class="collapse alert alert-success" id="solution-collapse-29">
   
<p>The mystery edge is {R, Z}. Based on our answer to part (iii), we know that there has to be an edge from something in the bottom half up to Z, or otherwise we‚Äôd visit node C after node H. Combining that with part (ii), the only possibility is {R, Z}.</p>

<blockquote>
  <p><strong>Thanks for reading this far! Good luck on the final exam!</strong></p>
</blockquote>

</div>
</div>
<hr />

</li></ol>

<p>‚Äã</p>
</div>
        <div class="col-xs-hidden col-md-2"><nav class="fixed-top-right toc" id="toc"></nav></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

    <script>
      tocbot.init({
        // Where to render the table of contents.
        tocSelector: '#toc',
        // Where to grab the headings to build the table of contents.
        contentSelector: '#content',
        // Which headings to grab inside of the contentSelector element.
        headingSelector: 'h2, h3, h4',
      });
    </script>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials ¬© Stanford University 2021 </br>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2022-Mar-10
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
