<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="../../_assets/style/site.css" rel="stylesheet">
    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>
    <title>  CS106B Introduction to Linked Lists</title>
  </head>

  <!-- fill to height of viewport, flex col, footer will be mt-auto -->
  <body class="d-flex flex-column min-vh-100">
    <nav class="navbar fixed-top navbar-expand-md navbar-dark" role="navigation">
  <a class="navbar-brand" href="../../index.html">üè†CS106B </a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="navbar-collapse collapse"  id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      
        
          <li class="nav-item"><a class="nav-link" href="../../syllabus.html">Syllabus</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../about_resources.html">Resources</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../about_lectures.html">Lectures</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../about_section.html">Sections</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../about_assignments.html">Assignments</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../about_exams.html">Exams</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="https://docs.google.com/spreadsheets/d/1klB-kNo6D-5i3l1joROtTqiPoGB8YorA/edit#gid=1136049055">üóìSchedule</a></li>
        
      
        
          <li class="nav-item"><a class="nav-link" href="../../search.html">üîçSearch</a></li>
        
      
    </ul>
    <!---
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" id="search-text" name="query" placeholder="üîç Search CS106B..." aria-label="Search" action="search">
    </form>
    --->
  </div>
</nav>

<style>
  .navbar {
    margin-bottom: 2rem;
  }
  .navbar-dark {
    background-color: #444;
  }
 .nav-item > a {
    text-transform: uppercase;
    letter-spacing: .08rem;
    font-size: small;
    color: #bbb !important;
  }
  .nav-item > a:hover {
    color: white !important;
  }
</style>
    
    <main class="main container-fluid" role="main"><div class="body-container container-fluid" data-spy="scroll" data-target="#toc">

<h1 class="title">Lecture 19. Introduction to Linked Lists</h1>
 <p class="subtle-heading">Wednesday November 8</p>
<hr>

<p class="attribution">

</p>



<div id="content"><p>Today we introduce our first node-based linked data structure: the linked list!</p>

<!-- This boilerplate inserts links to slides, Q&A, and video if available -->

<!--  Boilerplate content for lecture index page -->

<ul>
  <li>Readings: <a href="https://web.stanford.edu/dept/cs_edu/resources/textbook/">Text</a> 12.2, 13.5</li>
  <li><a href="https://canvas.stanford.edu/courses/178622/quizzes/144303">Lecture quiz on Canvas</a></li>
</ul>

<p><strong>Lecture Video</strong></p>
<iframe src="https://stanford-pilot.hosted.panopto.com/Panopto/Pages/Embed.aspx?id=fab6126c-490d-4ec1-871c-b083014df3b9&amp;autoplay=false&amp;offerviewer=true&amp;showtitle=true&amp;showbrand=true&amp;captions=true&amp;interactivity=all" height="405" width="720" style="border: 1px solid #464646;" allowfullscreen="" allow="autoplay" aria-label="Panopto Embedded Video Player"></iframe>

<p><br /><strong>Contents</strong></p>
<p>1. Warning: Here Be Dragonsüî•üêâ</p>
<p>2. Arrays and Linked Lists: Summary of Key Points</p>
<p>3. Preliminary Note: <span class="code-chonk">nullptr</span></p>
<p>4. Linked List Visualization: The Basic Anatomy of a Linked List</p>
<p>5. Draw Diagrams and Embrace the Memory Addresses!</p>
<p>6. <strong><span style="display: inline-block; font-size: 10pt; padding-top: 3px; background-color: #236fa1; color: #ffffff;">&nbsp;&nbsp;Incredibly Important!&nbsp;&nbsp;</span></strong>&nbsp; Preliminary Note: Passing Pointers by Reference ü§Ø</p>
<p>7. Preliminary Note: The Arrow Operator (<span class="code-chonk">-&gt;</span>)</p>
<p>8. First Draft: A Clunky Assemblage of a Linked List</p>
<p>9. Second Draft: A More Refined Approach to Node Creation (and a Print Function)</p>
<p>10. Third Draft: A More Elegant Assemblage of a Linked List (a Tail Insertion Function)</p>
<p>11. Cheeky Aside: Nodes That Hold Characters</p>
<p>12. What's next?</p>
<p>13. Exercises</p>
<p><br /><strong>Warning: Here Be Dragonsüî•üêâ</strong></p>
<p>I introduced linked lists today, and I started with a bit of a warning: these can be really tough when you first see them! They're quite sophisticated in that they involve a lot of pointer manipulation and dynamic memory management. I encourage you to dig in on the lecture notes, start your linked lists assignment early, re-watch today's lecture as needed, head to LaIR and office hours for help, and ask plenty of questions.</p>
<p>Perhaps most importantly: don't feel discouraged if you find this topic tricky. It's one of the harder things we'll cover in this class, and you are definitely not alone if you find yourself struggling with this material. Remember, the course staff understands that this can be tough, and we are here to support you, but we can only do that if you come ask us for help.</p>
<p><br /><strong>Arrays and Linked Lists: Summary of Key Points</strong></p>
<p>At the top of lecture, and then peppered throughout the remainder of the class, I made some comments about the nature of arrays and linked lists and some of the comparative strengths and weaknesses of these data structures. We saw that the strengths and weaknesses of linked lists are effectively the inverse of the strengths and weaknesses of arrays. Here is a summary of those remarks:</p>
<ul>
<li style="margin-top: 5px;"><strong>Arrays</strong>
<ul>
<li style="margin-top: 5px;"><em>Structure</em>
<ul>
<li style="margin-top: 5px;">Recall that the cells of an array are contiguous in memory, meaning they're stored right next to one another in one big chunk.</li>
</ul>
</li>
<li style="margin-top: 5px;"><em>Strengths</em>
<ul>
<li style="margin-top: 5px;">We have O(1) access to any cell in an array. When we access, say, <span class="code-chonk">array[3]</span>, C++ does a quick calculation behind the scenes: it knows the base memory address where the array is stored, and it adds to that however much memory it takes to move forward three cells from that address. The size of a cell is based on how many bytes are in the type of data we're storing in that array, and C++ knows that data type from our array declaration. The calculation and subsequent jump to that memory address is incredible fast and occurs in O(1) time. (When we access <span class="code-chonk">array[3]</span>, C++ does <strong>not</strong> start at the beginning of the array and loop forward three cells, one by one.)</li>
<li style="margin-top: 5px;">We can binary search a sorted array, which is just so fantastic. We love ourselves an O(log n) runtime.</li>
</ul>
</li>
<li style="margin-top: 5px;"><em>Potential Weaknesses (depending on application)</em>
<ul>
<li style="margin-top: 5px;">We sometimes underestimate how large an array needs to be when we first create it. This is often the case with arrays underlying ADTs like vectors, stacks, and queues. If we create an array with an initial length of 10 but then add 11 elements to it, the insertion of that 11th element forces us to stop and allocate a new, larger array, then copy the contents of the old array into the new one, and free up the old array -- a slow, expensive, O(n) operation.</li>
<li style="margin-top: 5px;">Conversely, we sometimes overestimate how large an array needs to be when we first create it. This can lead to wasted space in memory. This might not be a huge deal if we only have one such array in memory, but if we have several -- or if we're running several programs at once that waste memory unnecessarily -- the strain on system resources can actually impact the performance of our programs.</li>
<li style="margin-top: 5px;">Maintaining a sorted array can be expensive. If we have a bunch of sorted elements in indices 0 through&nbsp;<em>k</em> in an array of length&nbsp;<em>n</em> (where&nbsp;<em>k</em> &lt;&nbsp;<em>n</em>), adding a new smallest element at index 0 requires us to scooch over all <em>k</em> existing elements, one by one -- a slow, O(k) operation. (Adding a new largest element at index&nbsp;<em>n</em>, however, is a fast, O(1) operation -- provided the array still has an unused cell for us to occupy.)</li>
<li style="margin-top: 5px;">Because the cells of an array must be contiguous in memory, it's possible that we could have trouble finding space for an array in a memory-constrained system where we technically have enough memory to hold all the elements, but have a situation where memory has become highly fragmented (i.e., we have a pocket of memory here and a pocket of memory there, and our total memory free across all those pockets or fragments is certainly enough to hold all the elements we want, but there isn't one <strong>contiguous</strong> chunk available for that purpose).</li>
</ul>
</li>
</ul>
</li>
<li style="margin-top: 5px;"><strong>Linked Lists</strong>
<ul>
<li style="margin-top: 5px;"><em>Structure</em>
<ul>
<li style="margin-top: 5px;">Whereas arrays are made up of cells, linked lists are made up of nodes.</li>
<li style="margin-top: 5px;">Just as each cell in an array contains a single value, each node in a linked list contains a single value. Today, I focused on linked lists where each node held an integer, but we can code up our nodes to hold any type of data we want.</li>
<li style="margin-top: 5px;">The nodes of a linked list are scattered throughout memory. Each node contains a memory address telling us where to go to find the next node in our list. In this way, the nodes are "linked" together (hence the named "linked list"). Journeying through a linked list is like following a trail of breadcrumbs through memory.</li>
<li style="margin-top: 5px;">We bundle together these pieces of information (a <span class="code-chonk">data</span> field and a <span class="code-chonk">next</span> pointer) in <span class="code-chonk">node</span> struct.</li>
<li style="margin-top: 5px;">We refer to the first node in our linked list as the <strong>head</strong> of the list. We maintain a pointer to that node (often in a variable called <span class="code-chonk">head</span>), and it serves as our primary (and often only) entry point to the list.</li>
</ul>
</li>
<li style="margin-top: 5px;"><em>Strengths</em>
<ul>
<li style="margin-top: 5px;">Linked lists grow dynamically to accommodate the number of elements they contain. We never have wasted space (in the sense of allocating more nodes than we need in our list), and our list never "fills up" in a way that requires an disruptive, expensive reallocation or copying-over of all our elements into new spaces.</li>
<li style="margin-top: 5px;">Adding to the beginning of a linked list is a fast operation! Even if we have a huge linked list with&nbsp;<em>n</em> elements, adding a new element to the beginning of our list is simply a matter of creating a new node, setting its <span class="code-chonk">next</span> pointer to the old head of our linked list, and setting the head to point to our newly created node. All of this can be done in O(1) time, regardless of how long our list is.</li>
</ul>
</li>
<li style="margin-top: 5px;"><em>Potential Weaknesses (depending on application)</em>
<ul>
<li style="margin-top: 5px;">Accessing the <em>k</em><sup>th</sup> element is a slow, O(k) operation (compared to the array's O(1) access of an arbitrary cell) because we have to start at the head of the linked list and loop forward through our nodes one by one. This means that adding nodes to the middle or end of our linked list is expensive. (The opposite was true of an array. Inserting toward the end of an array was fairly fast because it required us to scooch fewer elements over.) We will see later, however, that we can achieve fast insertion at the very end of a linked list, and there is a variant of linked lists that allows for quick insertion at other positions prior to the very end of the list, as well.</li>
<li style="margin-top: 5px;">Because of the linked nature of these lists, and because we do not maintain pointers that allow us O(1) access to the&nbsp;<em>k</em><sup>th</sup> element for all <em>k</em>, we cannot perform binary search on a traditional linked list. We're stuck with a search runtime that is linear in the worst case rather than logarithmic.</li>
<li style="margin-top: 5px;">The nodes take up more memory than the cells in an array. On most systems these days, a C++ integer takes up 4 bytes (32 bits) of memory. So, an array of&nbsp;<em>n</em> integers requires 4<em>n</em> bytes of memory. Each node in a linked list holds not only a 4-byte integer, but also a <span class="code-chonk">next</span> pointer. On most systems these days, a C++ pointer takes up 8 bytes (64 bits) of memory. That means each node takes a total of 12 bytes of memory, and a linked list with&nbsp;<em>n</em> nodes requires approximately 12<em>n</em> bytes in total -- 3x the amount of space required for an array of the same length!</li>
</ul>
</li>
</ul>
</li>
<li style="margin-top: 5px;"><strong>Overbranching Comments</strong>
<ul>
<li style="margin-top: 5px;">Just as we can use arrays to build up abstract data structures like vectors, stacks, and queues, we can also use linked lists to build up ADTs. The trade-offs here are as described above.</li>
</ul>
</li>
</ul>
<p><strong><br />Preliminary Note: <span class="code-chonk">nullptr</span></strong></p>
<p>Before diving into the anatomy of a linked list, I mentioned there is a special value in C++ that we can assign to a pointer to indicate that it isn't pointing anywhere useful: <span class="code-chonk">nullptr</span>. We often use this when we create a pointer that we're not ready to have point to another variable yet, or to obliterate our copy of a memory address to some dynamically allocated space that we have since freed with <span class="code-chonk">delete</span>. We can then check whether a pointer is null or not before dereferencing it. This is called "coding defensively." For example:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;">#include &lt;iostream&gt;<br />#include "console.h"<br />using namespace std;<strong><br /><br />int</strong> main()<br />{<br />   <strong>int</strong> *ptr = <strong>nullptr</strong>;<br /><br /><span style="color: #236fa1;"><em>   // Suppose we have many lines of code here, and the logic is complex and twisty,</em></span><br /><span style="color: #236fa1;"><em>   // and we aren't quite sure at first glance whether ptr has ever been updated to</em></span><br /><span style="color: #236fa1;"><em>   // point to an actual integer. If not, we don't want to dereference it, because</em></span><br /><span style="color: #236fa1;"><em>   // that could lead to a segmentation fault and crash our program.</em></span><br /><span style="color: #236fa1;"><em>   //</em></span><br /><span style="color: #236fa1;"><em>   // No worries! We can just check whether its still nullptr, like so:</em></span><br /><br />   <strong>if</strong> (ptr != <strong>nullptr</strong>)<br />   {<br />      <strong>cout</strong> &lt;&lt; "Aha! It's safe to dereference ptr." &lt;&lt; <strong>endl</strong>;<br />      *ptr = 50;<br />   }<br />   <strong>else</strong><br />   {<br />      <strong>cout</strong> &lt;&lt; "OoOOOOoh! We didn't dereference the pointer! Hooray!" &lt;&lt; <strong>endl</strong>;<br />   }<br /><br />   <strong>return</strong> 0;<br />}</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>output:</strong></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #000000;"><span style="color: #ffffff;"><span style="color: #ffffff;">OoOOOOoh! We didn't dereference the pointer! Hooray!<br /></span></span></pre>
<p>(<span style="font-size: 10pt; background-color: #ffff99;"><em>Important note!</em></span>) Dereferencing a null pointer will cause a segmentation fault ("segfault" for short) and crash our program:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;">#include &lt;iostream&gt;<br />#include "console.h"<br />using namespace std;<br /><strong><br />int</strong> main()<br />{<br />   <strong>int</strong> *ptr = <strong>nullptr</strong>;<br /><br />   <span style="background-color: #ba372a; color: #ffffff;"><strong>// This will cause a segmentation fault!</strong></span><br />   *ptr = 50;<br /><br />   <strong>return</strong> 0;<br />}</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>output:</strong></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #eeeeee;"><span style="color: #e03e2d;">*** STANFORD C++ LIBRARY<br />*** The LinkedLists program has terminated unexpectedly (crashed)<br />*** A segmentation fault (SIGSEGV) occurred during program execution<br /><br />    This error indicates your program attempted to dereference a pointer<br />    to an invalid memory address (possibly out of bounds, deallocated, nullptr, ...)<br /><br />*** To get more information about a program crash,<br />*** run your program again under the debugger.</span></pre>
<p><strong><br />Linked List Visualization: The Basic Anatomy of a Linked List</strong></p>
<p>In class, I ran a program that generated a linked list diagram, where the values (data) in the diagram were based on command line input in my terminal. We used this to explore the basic anatomy of a linked list and see how nodes are linked together in memory, despite the fact that they're not necessarily contiguous in memory like arrays are. Here, we see successively larger linked lists and explore how the nodes are linked together:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #000000;"><span style="color: #ffffff;"><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> listmaker<br /><br />   head = NULL  (empty list)<br /><br /><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> ./a.out 87<br /><br /> addr: &nbsp; &nbsp;0xf9800<br />  &nbsp; &nbsp; &nbsp; +---------+<br /> data: &nbsp;| &nbsp; 87 &nbsp; &nbsp;|<br />  &nbsp; &nbsp; &nbsp; +---------+<br /> next: &nbsp;| nullptr |<br />  &nbsp; &nbsp; &nbsp; +---------+<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;head = 0xf9800<br /><br /><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> ./a.out 87 93<br /><br /> addr: &nbsp; &nbsp;0xf9800 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0xf4d33<br />  &nbsp; &nbsp; &nbsp; +---------+ &nbsp; &nbsp; &nbsp;+---------+<br /> data: &nbsp;| &nbsp; 87 &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;| &nbsp; 93 &nbsp; &nbsp;|<br />  &nbsp; &nbsp; &nbsp; +---------+ ---&gt; +---------+<br /> next: &nbsp;| 0xf4d33 | &nbsp; &nbsp; &nbsp;| nullptr |<br />  &nbsp; &nbsp; &nbsp; +---------+ &nbsp; &nbsp; &nbsp;+---------+<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;head = 0xf9800<br /><br /><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> ./a.out 87 93 12<br /><br />&nbsp;addr: &nbsp; &nbsp;0xf9800 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0xf4d33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0xc625e<br />&nbsp; &nbsp; &nbsp; &nbsp; +---------+ &nbsp; &nbsp; &nbsp;+---------+ &nbsp; &nbsp; &nbsp;+---------+<br />&nbsp;data: &nbsp;| &nbsp; 87 &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;| &nbsp; 93 &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;| &nbsp; 12 &nbsp; &nbsp;|<br />&nbsp; &nbsp; &nbsp; &nbsp; +---------+ ---&gt; +---------+ ---&gt; +---------+<br />&nbsp;next: &nbsp;| 0xf4d33 | &nbsp; &nbsp; &nbsp;| 0xc625e | &nbsp; &nbsp; &nbsp;| nullptr |<br />&nbsp; &nbsp; &nbsp; &nbsp; +---------+ &nbsp; &nbsp; &nbsp;+---------+ &nbsp; &nbsp; &nbsp;+---------+<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;head = 0xf9800<br /><br /><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> _</span></pre>
<p>Despite the convention of drawing nodes in neat rows, connected by arrows, the nodes are scattered throughout memory. A more accurate diagram would look like the following, but this is chaotic and hard to read, so we never really depict linked lists this way:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #000000;"><span style="color: #ffffff;"><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> listmaker 87 93 12 --chaos-mode<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x1197d<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +---------+<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data: | &nbsp; 87 &nbsp; &nbsp;|<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +---------+<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next: | 0xaf30c |<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +---------+<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x7c264<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------+<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data: | &nbsp; 12 &nbsp; &nbsp;|<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------+<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next: | nullptr |<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------+<br /><br /><br /><br /><br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0xaf30c<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------+<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data: | &nbsp; 93 &nbsp; &nbsp;|<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------+<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next: | 0x7c264 |<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+---------+<br /><br />   head = 0x1197d<br /><br /><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> ./a.out 87</span></pre>
<p>&nbsp;</p>
<p><strong>Draw Diagrams and Embrace the Memory Addresses!</strong></p>
<p>When you're writing code with linked lists, and especially when you're trying to debug linked list code, be sure to...</p>
<p style="padding-left: 40px;"><span style="color: #236fa1;"><strong><span style="font-size: 36pt;">DRAW LOTS OF DIAGRAMS!</span></strong></span></p>
<p>And include memory addresses in your diagrams (whether made up or copied from the output of your programs) to make things more concrete.</p>
<p>It's true that in the real world, we often see linked lists drawn as follows, without any memory addresses attached:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #000000;"><span style="color: #ffffff;"><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> listmaker 87 93 12 --basic-mode<br /><br />&nbsp; &nbsp; &nbsp;+------+ &nbsp; &nbsp; +------+ &nbsp; &nbsp; +------+<br />&nbsp; &nbsp; &nbsp;| &nbsp;87 &nbsp;| --&gt; | &nbsp;93 &nbsp;| --&gt; | &nbsp;12 &nbsp;|<br />&nbsp; &nbsp; &nbsp;+------+ &nbsp; &nbsp; +------+ &nbsp; &nbsp; +------+<br />&nbsp; &nbsp; &nbsp; &nbsp; ^<br />&nbsp; &nbsp; &nbsp; &nbsp; head<br /><br /><span style="color: #00ccff;"><span style="color: #00ff00;">seansz</span> ~/Desktop $</span> ./a.out 87</span></pre>
<p>This is fine for a quick and dirty visualization, but including memory addresses in the diagrams we draw can be super helpful when debugging code that involves linked lists. (The diagram above also doesn't quite make the distinction that <span class="code-chonk">head</span> is a separate variable in memory that just holds the <em>address</em> of the head node; it is a pointer and not an actual node itself.)</p>
<p>My personal opinion is that when we're first learning about linked lists, abstracting away too many details actually makes it <em>harder</em> to understand how they work and what's going on. Even though memory addresses might look intimidating at first, embracing the details and complexity of what's really happening in our nodes -- and not being afraid to print memory addresses to the screen, draw them in our diagrams, or keep track of them in the debugger -- will lead to a better understanding of linked lists and stronger coding competency.</p>
<p><strong><br />Preliminary Note: Passing Pointers by Reference ü§Ø</strong></p>
<p>As we work with linked lists, we will have to write functions that can modify pointers that we pass to them. To do that, we will pass pointers by reference. To lead into that, I want to start with a bit of a simplified example. Suppose we have a pointer to an integer in <span class="code-chonk">main()</span>:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;"><strong>int</strong> main()<br />{<br />   <strong>int</strong> x = 50;<br />   <strong>int</strong> *ptr = &amp;x;<br /><br /><em><span style="color: #236fa1;">   // ... presumably, we would do other things here ...</span></em><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>Memory Diagram: </strong>Here's what things look like before we <span class="tiny-chonk">return 0;</span> in <span class="tiny-chonk">main()</span>. (The memory addresses are made up, but the struggle is real.)<br /></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #eeeeee;"><strong>main():</strong><br /><br />   x     0xdec08<br />   +-----------+<br />   |    50     |<br />   +-----------+<br /><br />   ptr   0x55824<br />   +-----------+<br />   | &nbsp;0xdec08  |<br />   +-----------+</pre>
<p>So far, so good?</p>
<p>Now, suppose we pass that pointer to a function that takes an <span class="code-chonk">int *</span> parameter. If we do that, we will get an <strong>entirely new copy</strong> of that pointer in our other function. Changing its value there will&nbsp;<strong>not</strong> change the value of <span class="code-chonk">ptr</span> back in <span class="code-chonk">main()</span>. Check this out:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;"><strong>void</strong> illuminate(<strong>int</strong> *ptr)<br />{<br />   ptr = <strong>nullptr</strong>;<br />}<strong><br /><br />int</strong> main()<br />{<br />   <strong>int</strong> x = 50;<br />   <strong>int</strong> *ptr = &amp;x;<br /><br />   <span style="background-color: #ffcc99;">illuminate(ptr);</span><br /><br /><em><span style="color: #236fa1;">   // ... presumably, we would do other things here ...</span></em><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>Memory Diagram: </strong>Here's what things look like when we call <span class="tiny-chonk">illuminate(ptr)</span> -- <span style="background-color: #ffff99;"><strong><span style="text-decoration: underline;"><em>before</em></span></strong></span> executing the <span class="tiny-chonk">ptr = nullptr</span> line.<br /></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #eeeeee;"><strong>illuminate():<br /></strong><br />   ptr<br />   +------------+<br />   |  0xdec08   | <strong>&lt;-- illuminate() has its own local variable called ptr!<br /></strong>   +------------+<strong>     This is *not* the same variable as the one in main()!<br /><br />main():</strong><br /><br />   x     0xdec08<br />   +-----------+<br />   |    50     |<br />   +-----------+<br /><br />   ptr   0x55824<br />   +-----------+<br />   | &nbsp;0xdec08  |<br />   +-----------+</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>Memory Diagram: </strong>Here's what things look <span style="background-color: #ffff99;"><strong><span style="text-decoration: underline;"><em>after</em></span></strong></span> executing the <span class="tiny-chonk">ptr = nullptr</span> line in <span class="tiny-chonk">illuminate()</span>.<br /></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #eeeeee;"><strong>illuminate():<br /></strong><br />   ptr<br />   +------------+<br />   |  nullptr   | <strong>&lt;-- We only changed the local copy of nullptr.<br /></strong>   +------------+<strong>     This does *not* affect the copy back in main()!<br /><br />main():</strong><br /><br />   x     0xdec08<br />   +-----------+<br />   |    50     |<br />   +-----------+<br /><br />   ptr   0x55824<br />   +-----------+<br />   | &nbsp;0xdec08  |<strong> &lt;-- This remains unaffected!</strong><br />   +-----------+</pre>
<p>If we want to empower the <span class="code-chonk">illuminate()</span> function to go back to <span class="code-chonk">main()</span> and change the value inside that <span class="code-chonk">ptr</span> variable, we need to pass it by&nbsp;<span style="text-decoration: underline;"><em><strong>reference</strong></em></span>. As we saw in <a class="inline_disabled" href="../03-strings/index.html" target="_blank" rel="noopener">our first lecture on pass-by-reference parameters</a>, the way to create a reference is to inject an ampersand (<span class="code-chonk">&amp;</span>) in front of the parameter name in question:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;"><span style="color: #236fa1;"><em>// <span style="background-color: #ffcc99; color: #000000;"><strong>Super important note!</strong></span><br />// By injecting an ampersand here, we turn this ptr variable into a <strong><span style="text-decoration: underline;">reference</span></strong> to the</em></span><br /><span style="color: #236fa1;"><em>// pointer variable back in whatever function called this one. ptr is now an alias or</em></span><br /><span style="color: #236fa1;"><em>// synonym for the corresponding parameter back in our calling function. If we set</em></span><br /><span style="color: #236fa1;"><em>// ptr equal to something, we're actually changing the value contained in the</em></span><br /><span style="color: #236fa1;"><em>// corresponding variable back in our calling function.<br /></em></span><strong>void</strong> illuminate(<strong>int</strong> *<span style="background-color: #ffcc99;">&amp;</span>ptr)<br />{<br />   ptr = <strong>nullptr</strong>;<br />}<strong><br /><br />int</strong> main()<br />{<br />   <strong>int</strong> x = 50;<br />   <strong>int</strong> *ptr = &amp;x;<br /><br />   illuminate(<em>ptr</em>);<br /><br /><em><span style="color: #236fa1;">   // ... presumably, we would do other things here ...</span></em><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>Memory Diagram: </strong>Here's what things look like when we call <span class="tiny-chonk">illuminate(ptr)</span> -- <span style="background-color: #ffff99;"><strong><span style="text-decoration: underline;"><em>before</em></span></strong></span> executing the <span class="tiny-chonk">ptr = nullptr</span> line.<br /></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #eeeeee;"><strong>illuminate():<br /></strong><br />   ptr<br />   +------------+<br />   |    &nbsp;üåÄ   &nbsp; | <strong>&lt;-- Because we passed by reference, this is now just a portal to<br /></strong>   +------|-----+<strong>     the ptr variable back in main()! It no longer has its own copy<br />          </strong>|                   <strong>of the memory address in question (0xdec08)!</strong><strong><br />main():</strong>   +----------+<br />                     |<br />   x     0xdec08     |<br />   +-----------+     |<br />   |    50     |     |<br />   +-----------+     |<br />                     |<br />   ptr   0x55824     |<br />   +-----------+     |<br />   | &nbsp;0xdec08 &nbsp;&lt;-----+<br />   +-----------+</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>Memory Diagram: </strong>Here's what things look <span style="background-color: #ffff99;"><strong><span style="text-decoration: underline;"><em>after</em></span></strong></span> executing the <span class="tiny-chonk">ptr = nullptr</span> line in <span class="tiny-chonk">illuminate()</span>.<br /></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #eeeeee;"><strong>illuminate():<br /></strong><br />   ptr<br />   +------------+<br />   |    &nbsp;üåÄ &nbsp;   | <strong>&lt;-- Nothing has changed here. This is still just a portal to the<br /></strong>   +------|-----+<strong>     ptr variable back in main()!<br /></strong>          |<strong><br />          |<br />main():</strong>   +----------+<br />                     |<br />   x     0xdec08     |<br />   +-----------+     |<br />   |    50     |     |<br />   +-----------+     |<br />                     |<br />   ptr 0x55824       |<br />   +-----------+     |<br />   | &nbsp;nullptr &nbsp;&lt;-----+   <strong>&lt;-- This value changed! Since the ptr in illuminate() was just</strong><br />   +-----------+             <strong>a <span style="text-decoration: underline;">reference</span> (i.e., portal) to this pointer, changing ptr</strong><br />                             <strong>in illuminate() actually changed the value of this pointer</strong><br />                                                  <strong>back in main()!</strong></pre>
<p>(<span style="font-size: 10pt; background-color: #ffff99;"><em>Key take-away!</em></span>) If you have a pointer in some function <span class="code-chonk">x()</span>, and you want some function <span class="code-chonk">y()</span> to be able to change the value that the pointer in function <span class="code-chonk">x()</span> contains, you should pass that pointer to <span class="code-chonk">y()</span> by reference using a <span class="code-chonk">*&amp;</span> parameter.</p>
<p>(<span style="font-size: 10pt; background-color: #ffff99;"><em>Important note!</em></span>) Understanding the content in this section will be absolutely critical as we move through the quarter. If anything about this is unclear, please seek out clarification immediately. You can talk to other people in the class, your SL, or head to LaIR or office hours. We want to help you understand what's going on here and set you up for success moving forward!</p>
<p>(<span style="font-size: 10pt; background-color: #eccafa;"><em>Side note...</em></span>) We could also give <span class="code-chonk">illuminate()</span> the power to change <span class="code-chonk">ptr</span> back in <span class="code-chonk">main()</span> by passing the function a "double pointer" (a pointer to a pointer: <span class="code-chonk">int **ptr</span>), but that's a bit more complex. We'll just stick to pointer references for this quarter to keep things a bit more manageable.</p>
<p><br /><strong>Preliminary Note: The Arrow Operator (<span class="code-chonk">-&gt;</span>)</strong></p>
<p>We have seen previously that if we want to access a field within a struct variable, we use the dot operator (<span class="code-chonk">.</span>). Today, we saw that if we have a&nbsp;<em>pointer</em> to a struct, we can access its fields using the arrow operator (<span class="code-chonk">-&gt;</span>). If we instead try to apply a dot operator to a struct&nbsp;<em>pointer</em>, C++ will give us an error; it won't even compile our program. (See below for examples.)</p>
<p>(<span style="font-size: 10pt; background-color: #ffff99;"><em>Important note!</em></span>) Instead of using the <span class="code-chonk">-&gt;</span> operator as in <span class="code-chonk">myStruct-&gt;myField</span>, we could instead do something like this: <span class="code-chonk">(*myStruct).myField</span>. Please never do that, though! That is very unconventional, involves more keystrokes than simply typing <span class="code-chonk">-&gt;</span>, and is considered by many to be poor style / poor form.</p>
<p><br /><strong>First Draft: A Clunky Assemblage of a Linked List</strong></p>
<p>Finally, we dove into linked list code. We created a <span class="code-chonk">Node</span> struct, and we then collaboratively worked through the code to construct a linked list in <span class="code-chonk">main()</span> in a slow, clunky way:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;">#include &lt;iostream&gt;<br />#include "console.h"<br />using namespace std;<br /><br /><strong>struct</strong> Node<br />{<br />   <strong>int</strong> data;<br />   <strong>Node</strong> *next;  <span style="color: #236fa1;"><em>// a pointer to a Node -- the next node in our list</em></span><br />};<br /><br /><strong>int</strong> main()<br />{<br />   <strong>Node</strong> *head = <strong>nullptr</strong>;<br /><br />   head = <strong>new</strong> Node;<br />   head-&gt;data = 10;<br />   head-&gt;next = <strong>nullptr</strong>;<br /><br /><em><span style="color: #236fa1;">   // Here's what we have so far:</span></em><br /><em><span style="color: #236fa1;">   //</span></em><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> addr:    0xf9800</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> data:  |   10    |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> next:  | nullptr |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+</span><br /><br /><span style="color: #236fa1;"><em>   // Let's continue hooking up nodes manually. In class, we carefully explored how</em></span><br /><span style="color: #236fa1;"><em>   // the following lines constructed a valid linked list. (See timestamp 29:30 in</em></span><br /><span style="color: #236fa1;"><em>   // today's lecture for the details.)</em></span><br /><br />   head-&gt;next = <strong>new</strong> Node;<br />   head-&gt;next-&gt;data = 25;<br />   head-&gt;next-&gt;next = <strong>nullptr</strong>;<br /><br /><em><span style="color: #236fa1;">   // We now have the following:</span></em><br /><em><span style="color: #236fa1;">   //</span></em><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> addr:    0xf9800          0xf4d33</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> data:  |   10    |      |   25    |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+ ---&gt; +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> next:  | 0xf4d33 |      | nullptr |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+</span><br /><br /><em><span style="color: #236fa1;">   // Let's keep going...</span></em><br /><br />   head-&gt;next-&gt;next = <strong>new</strong> Node;<br />   head-&gt;next-&gt;next-&gt;data = 12;<br />   head-&gt;next-&gt;next-&gt;next = <strong>nullptr</strong>;<br /><br /><em><span style="color: #236fa1;">   // We now have the following:</span></em><br /><em><span style="color: #236fa1;">   //</span></em><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> addr:    0xf9800          0xf4d33          0xc625e</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+      +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> data:  |   10    |      |   25    |      |   12    |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+ ---&gt; +---------+ ---&gt; +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> next:  | 0xf4d33 |      | 0xc625e | &nbsp; &nbsp;  | nullptr |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+ &nbsp; &nbsp; &nbsp;+---------+</span><br /><br /><span style="color: #236fa1;"><em>   // <strong>WARNING!<br /></strong>   // This has a memory leak! We aren't freeing the list before returning</em><em> from main().</em></span><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p>That's pretty painful. We obvious can't keep this up. If we want to add a 100th node to a linked list, it would be absurd to have a condition that checked for that and then executed a line with 99 instances of <span class="code-chonk">-&gt;next</span>. Let's refine our approach a bit.</p>
<p><strong><br />Second Draft: A More Refined Approach to Node Creation (and a Print Function)</strong></p>
<p>When I see chunks of repeated code like what we have above (create node, set <span class="code-chonk">data</span> field, set <span class="code-chonk">next</span> field to <span class="code-chonk">nullptr</span>), start to think about using functions to make my code more readable, compact, and maintainable (if I discover a bug in those lines of code, I only want to have to update one copy of those lines -- not several copies that are scattered all over <span class="code-chonk">main()</span>). Here's how we did that:</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;">#include &lt;iostream&gt;<br />#include "console.h"<br />using namespace std;<br /><br /><strong>struct</strong> Node<br />{<br />   <strong>int</strong> data;<br />   <strong>Node</strong> *next;  <span style="color: #236fa1;"><em>// a pointer to a Node -- the next node in our list</em></span><br />};<br /><br /><span style="color: #236fa1;"><em>// Dynamically allocates a new node with the given data and returns a pointer</em></span><br /><span style="color: #236fa1;"><em>// to that node.</em></span><br /><span style="background-color: #ffcc99;"><strong>Node</strong> *createNode(<strong>int</strong> data)</span><br /><span style="background-color: #ffcc99;">{</span><br /><span style="background-color: #ffcc99;">   <strong>Node</strong> *n = <strong>new</strong> Node;</span><br /><span style="background-color: #ffcc99;">   n-&gt;data = data;</span><br /><span style="background-color: #ffcc99;">   n-&gt;next = <strong>nullptr</strong>;</span><br /><span style="background-color: #ffcc99;">   <strong>return</strong> n;</span><br /><span style="background-color: #ffcc99;">}</span><br /><br /><span style="color: #236fa1;"><em>// Prints the contents of our linked list.</em></span><br /><span style="background-color: #ffcc99;"><strong>void</strong> printList(Node *head)</span><br />{<br />   // Remember that this local variable called 'head' is separate from the one<br />   // called 'head' down in main()! We can change the address stored in this local<br />   // copy without changing what 'head' points to back in main(). So, we could<br />   // have moved 'head' forward through this list instead of creating the helper<br />   // variable, 'current'.<br /><br />   <strong>Node</strong> *current = head;<br /><br />   <strong>while</strong> (current != <strong>nullptr</strong>)<br />   {<br />      <strong>cout</strong> &lt;&lt; current-&gt;data;<br /><br /><span style="color: #236fa1;"><em>      // If this isn't the last node, print an arrow, because there's more to come.</em></span><br />      <strong>if</strong> (current-&gt;next != <strong>nullptr</strong>)<br />      {<br />         cout &lt;&lt; " -&gt; ";<br />      }<br /><br /><span style="color: #236fa1;"><em>      // Move our pointer forward in the list!</em></span><br />      current = current-&gt;next;<br />   }<br /><br />   <strong>cout</strong> &lt;&lt; <strong>endl</strong>;<br />}<br /><br /><strong>int</strong> main()<br />{<br />   <strong>Node</strong> *head = <strong>nullptr</strong>;<br /><br /><span style="color: #236fa1;"><em>   // We have dramatically refined our approach here, condensing 9 lines down to 3.</em></span><br />   <span style="background-color: #ffcc99;">head = createNode(10);</span><br />   <span style="background-color: #ffcc99;">head-&gt;next = createNode(25);</span><br />   <span style="background-color: #ffcc99;">head-&gt;next-&gt;next = createNode(12);</span><br /><br /><em><span style="color: #236fa1;">   // We now have the following:</span></em><br /><em><span style="color: #236fa1;">   //</span></em><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> addr:    0xf9800          0xf4d33          0xc625e</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+      +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> data:  |   10    |      |   25    |      |   12    |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+ ---&gt; +---------+ ---&gt; +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> next:  | 0xf4d33 |      | 0xc625e | &nbsp; &nbsp;  | nullptr |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+ &nbsp; &nbsp; &nbsp;+---------+</span><br /><br />   <span style="background-color: #ffcc99;">printList(head);</span><br /><br /><span style="color: #236fa1;"><em>   // <strong>WARNING!<br /></strong>   // This has a memory leak! We aren't freeing the list before returning</em><em> from main().</em></span><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p>(<span style="font-size: 10pt; background-color: #ffff99;"><em>Important note!</em></span>) We traced fairly carefully through the construction of the <span class="code-chonk">printList()</span> function above in class today, starting at timestamp 35:32 in our lecture.</p>
<p>(<span style="font-size: 10pt; background-color: #ffff99;"><em>Important note!</em></span>) Rather than creating an auxiliary function that exists outside our <span class="code-chonk">Node</span> struct, we could create a constructor function within the struct. (C does not allow that sort of thing, but C++ does.) We will see that alternative approach next time.</p>
<p><strong><br />Third Draft: A More Elegant Assemblage of a Linked List (a Tail Insertion Function)</strong></p>
<p>At the end of class, we saw the following approach to inserting elements at the tail of our linked list. Note the use of a reference parameter, which is described at length in one of the sections of notes above (and which we discussed briefly at timestamp 46:00 in the lecture).</p>
<p>(<span style="background-color: #ffff99; font-size: 10pt;"><em>Important note!</em></span>) In the code below, if we hadn't initialized <span class="code-chonk">head</span> to <span class="code-chonk">nullptr</span> in <span class="code-chonk">main()</span>, and if we didn't have a compiler flag set to prevent us from using uninitialized variables, then <span class="code-chonk">head</span> would contain a garbage memory address, and our tail insertion function would likely have crashed (unless that garbage address just happened to be <span class="code-chonk">nullptr</span>, which is certainly within the realm of possibility).</p>
<p>(<span style="background-color: #ffff99; font-size: 10pt;"><em>Important note!</em></span>) The tail insertion function below has a linear runtime. We will see a trick next time that actually allows us to achieve O(1) tail insertions.</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;">#include &lt;iostream&gt;<br />#include "console.h"<br />using namespace std;<br /><br /><strong>struct</strong> Node<br />{<br />   <strong>int</strong> data;<br />   <strong>Node</strong> *next;  <span style="color: #236fa1;"><em>// a pointer to a Node -- the next node in our list</em></span><br />};<br /><br /><span style="color: #236fa1;"><em>// Dynamically allocates a new node with the given data and returns a pointer</em></span><br /><span style="color: #236fa1;"><em>// to that node.</em></span><br /><strong>Node</strong> *createNode(<strong>int</strong> data)<br />{<br />   <strong>Node</strong> *n = <strong>new</strong> Node;<br />   n-&gt;data = data;<br />   n-&gt;next = <strong>nullptr</strong>;<br />   <strong>return</strong> n;<br />}<br /><br /><span style="color: #236fa1;"><em>// Prints the contents of our linked list.</em></span><br /><strong>void</strong> printList(Node *head)<br />{<br />   // Remember that this local variable called 'head' is separate from the one<br />   // called 'head' down in main()! We can change the address stored in this local<br />   // copy without changing what 'head' points to back in main(). So, we could<br />   // have moved 'head' forward through this list instead of creating the helper<br />   // variable, 'current'.<br /><br />   <strong>Node</strong> *current = head;<br /><br />   <strong>while</strong> (current != <strong>nullptr</strong>)<br />   {<br />      <strong>cout</strong> &lt;&lt; current-&gt;data;<br /><br /><span style="color: #236fa1;"><em>      // If this isn't the last node, print an arrow, because there's more to come.</em></span><br />      <strong>if</strong> (current-&gt;next != <strong>nullptr</strong>)<br />      {<br />         cout &lt;&lt; " -&gt; ";<br />      }<br /><br /><span style="color: #236fa1;"><em>      // Move our pointer forward in the list!</em></span><br />      current = current-&gt;next;<br />   }<br /><br />   <strong>cout</strong> &lt;&lt; <strong>endl</strong>;<br />}<br /><br /><span style="color: #236fa1;"><em>// Insert a new node at the end of the linked list. You can watch the creation of<br /></em><em>// this function at timestamp 46:00 in today's lecture.</em></span><br /><span style="background-color: #ffcc99;"><strong>void</strong> tailInsert(<strong>Node</strong> *&amp;head, <strong>int</strong> data)</span><br />{<br /><span style="color: #236fa1;"><em>   // If we have an empty list, just create a new node (which becomes our head)</em></span><br /><span style="color: #236fa1;"><em>   // and return back to main().</em></span><br />   <strong>if</strong> (head == <strong>nullptr</strong>)<br />   {<br />      head = createNode(data);<br />      <strong>return</strong>;<br />   }<br /><br />   <strong>Node</strong> *current = head;<br /><br /><span style="color: #236fa1;"><em>   // Loop forward until 'current' points to last node, which happens when its<br /></em><em>   // 'next' pointer is nullptr (<strong>not</strong> when current itself is nullptr; if that</em></span><br /><span style="color: #236fa1;"><em>   // happens, we will have fallen off the end of our list).</em></span><br />   <strong>while</strong> (current-&gt;next != <strong>nullptr</strong>)<br />   {<br />      current = current-&gt;next;<br />   }<br /><br /><span style="color: #236fa1;"><em>   // When we get here, 'current' points to the last node in the list. We set</em></span><br /><span style="color: #236fa1;"><em>   // its 'next' field equal to a new node to tack onto the end of the list.</em></span><br />   current-&gt;next = createNode(data);<br />}<br /><br /><strong>int</strong> main()<br />{<br />   <strong>Node</strong> *head = <strong>nullptr</strong>;<br /><br />   <span style="background-color: #ffcc99;">tailInsert(head, 10);</span><br />   <span style="background-color: #ffcc99;">tailInsert(head, 25);</span><br />   <span style="background-color: #ffcc99;">tailInsert(head, 12);</span><br /><br /><em><span style="color: #236fa1;">   // We now have the following:</span></em><br /><em><span style="color: #236fa1;">   //</span></em><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> addr:    0xf9800          0xf4d33          0xc625e</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+      +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> data:  |   10    |      |   25    |      |   12    |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+ ---&gt; +---------+ ---&gt; +---------+</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;"> next:  | 0xf4d33 |      | 0xc625e | &nbsp; &nbsp;  | nullptr |</span><br /><em><span style="color: #236fa1;">   //</span></em><span style="color: #236fa1;">        +---------+      +---------+ &nbsp; &nbsp; &nbsp;+---------+</span><br /><br />   printList(head);<br /><br /><span style="color: #236fa1;"><em>   // <strong>WARNING!<br /></strong>   // This has a memory leak! We aren't freeing the list before returning</em><em> from main().</em></span><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p><br /><strong>Cheeky Aside: Nodes That Hold Characters</strong></p>
<p>At the very end of class, I quickly modified the <span class="code-chonk">Node</span> struct to hold characters instead of integers and talked a bit about seeding random number generators along the way, which you have seen in your current assignment.</p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #fff9e7;">#include &lt;iostream&gt;<br />#include "console.h"<br /><span style="background-color: #ffcc99;">#include "random.h"</span><br />using namespace std;<br /><br /><strong>struct</strong> Node<br />{<br />   <span style="background-color: #ffcc99;"><strong>char</strong></span> data;<br />   <strong>Node</strong> *next;  <span style="color: #236fa1;"><em>// a pointer to a Node -- the next node in our list</em></span><br />};<br /><br /><span style="color: #236fa1;"><em>// Dynamically allocates a new node with the given data and returns a pointer</em></span><br /><span style="color: #236fa1;"><em>// to that node.</em></span><br /><strong>Node</strong> *createNode(<span style="background-color: #ffcc99;"><strong>char</strong></span> data)<br />{<br />   <strong>Node</strong> *n = <strong>new</strong> Node;<br />   n-&gt;data = data;<br />   n-&gt;next = <strong>nullptr</strong>;<br />   <strong>return</strong> n;<br />}<br /><br /><span style="color: #236fa1;"><em>// Prints the contents of our linked list.</em></span><br /><strong>void</strong> printList(Node *head)<br />{<br />   // Remember that this local variable called 'head' is separate from the one<br />   // called 'head' down in main()! We can change the address stored in this local<br />   // copy without changing what 'head' points to back in main(). So, we could<br />   // have moved 'head' forward through this list instead of creating the helper<br />   // variable, 'current'.<br /><br />   <strong>Node</strong> *current = head;<br /><br />   <strong>while</strong> (current != <strong>nullptr</strong>)<br />   {<br />      <strong>cout</strong> &lt;&lt; current-&gt;data;<br /><br /><span style="color: #236fa1;"><em>      // If this isn't the last node, print an arrow, because there's more to come.</em></span><br />      <strong>if</strong> (current-&gt;next != <strong>nullptr</strong>)<br />      {<br />         cout &lt;&lt; " -&gt; ";<br />      }<br /><br /><span style="color: #236fa1;"><em>      // Move our pointer forward in the list!</em></span><br />      current = current-&gt;next;<br />   }<br /><br />   <strong>cout</strong> &lt;&lt; <strong>endl</strong>;<br />}<br /><br /><span style="color: #236fa1;"><em>// Insert a new node at the end of the linked list. You can watch the creation of<br /></em><em>// this function at timestamp 46:00 in today's lecture.</em></span><br /><strong>void</strong> tailInsert(<strong>Node</strong> *&amp;head, <span style="background-color: #ffcc99;"><strong>char</strong></span> data)<br />{<br /><span style="color: #236fa1;"><em>   // If we have an empty list, just create a new node (which becomes our head)</em></span><br /><span style="color: #236fa1;"><em>   // and return back to main().</em></span><br />   <strong>if</strong> (head == <strong>nullptr</strong>)<br />   {<br />      head = createNode(data);<br />      <strong>return</strong>;<br />   }<br /><br />   <strong>Node</strong> *current = head;<br /><br /><span style="color: #236fa1;"><em>   // Loop forward until 'current' points to last node, which happens when its<br /></em><em>   // 'next' pointer is nullptr (<strong>not</strong> when current itself is nullptr; if that</em></span><br /><span style="color: #236fa1;"><em>   // happens, we will have fallen off the end of our list).</em></span><br />   <strong>while</strong> (current-&gt;next != <strong>nullptr</strong>)<br />   {<br />      current = current-&gt;next;<br />   }<br /><br /><span style="color: #236fa1;"><em>   // When we get here, 'current' points to the last node in the list. We set</em></span><br /><span style="color: #236fa1;"><em>   // its 'next' field equal to a new node to tack onto the end of the list.</em></span><br />   current-&gt;next = createNode(data);<br />}<br /><br /><strong>int</strong> main()<br />{<br />   <strong>Node</strong> *head = <strong>nullptr</strong>;<br /><br />   <span style="background-color: #ffcc99;">setRandomSeed(14104611);</span><br /><br />   <span style="background-color: #ffcc99;"><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 5; i++)</span><br />   {<br />      <em><span style="color: #236fa1;">// The range 65 through 122 corresponds to ASCII values for 'A' through 'Z'</span></em><br /><em><span style="color: #236fa1;">      // and a few other </span></em><br />      <span style="background-color: #ffcc99;">tailInsert(head, randomInteger(65, 122));</span><br />   }<br /><br />   printList(head);<br /><br /><span style="color: #236fa1;"><em>   // <strong>WARNING!<br /></strong>   // This has a memory leak! We aren't freeing the list before returning</em><em> from main().</em></span><br /><br />   <strong>return</strong> 0;<br />}</pre>
<p style="padding-left: 30px; width: 600px;"><span style="font-size: 13.3333px;"><strong>output:</strong></span></p>
<pre style="margin-left: 30px; font-family: monospace; font-size: 11px; width: 600px; background-color: #000000;"><span style="color: #ffffff;">u -&gt; r -&gt; m -&gt; o -&gt; m</span></pre>
<p><br /><strong>What's next?</strong></p>
<p>On Friday, we'll write a LOT more linked list code and explore a few variants of linked lists.</p>
<p><br /><strong>Exercises</strong></p>
<p>1. From scratch, replicate all the code we wrote in class today! Challenging yourself to sit down and rewrite this code is one of the best ways to get really great at all that pointer manipulation and dynamic memory management.</p>
<p>2. Trace through the <span class="code-chonk">printList()</span> function that we created in class today. Draw boxes for each of the local variables. See if you can convince yourself that this function isn't destroying our list (since we're doing <span class="code-chonk">current = ...</span>, not <span class="code-chonk">*current = ...</span>).</p>
<p>3. In <span class="code-chonk">printList()</span>, get rid of the <span class="code-chonk">current</span> variable altogether and simply use the local <span class="code-chonk">head</span> variable to loop forward through the list. Again, draw diagrams of what's happening in memory to help convince yourself that changing the local copy of <span class="code-chonk">head</span> in <span class="code-chonk">printList()</span> will not destroy the list in any way.</p>
<p>4. Why did we need a pointer reference (<span class="code-chonk">Node *&amp;head</span>) for our <span class="code-chonk">tailInsert()</span> function today, but for <span class="code-chonk">printList()</span>, we only used <span class="code-chonk">Node *head</span>? Also, be sure you understand why <span class="code-chonk">Node *</span> was the return type for our <span class="code-chonk">createNode()</span> function.</p>
<p>5. Write a function called <span class="code-chonk">void destroyList(Node *&amp;head)</span> that takes the head of a linked list and frees up all dynamically allocated memory associated with that list. Call it on the list above and ensure that it doesn't crash. Be sure to test your destroyer function on linked lists of sizes 1 and 2 as well, and make sure it doesn't crash if it's passed an empty list (a <span class="code-chonk">nullptr</span>). Have your function set <span class="code-chonk">head</span> to <span class="code-chonk">nullptr</span> before returning so that when we get back to <span class="code-chonk">main()</span> (or whatever other function might have called the destroyer function), the variable that once held the linked list pointer has been nullified, and we therefore can't accidentally use it to go back to a chunk of memory over which our program no longer has any claim.</p>
<p>6. Be sure to read the course textbook for more detail or alternative perspectives if you're finding this material really tricky.</p>
<p>7. Dive into the current programming assignment, where you'll get some really solid practice coding with linked lists. If you find that assignment too difficult at first, come back to this page and be sure to work through all the exercises above before moving on. That will likely be less frustrating in the long run if skipping straight to something that feels a bit too advanced at first.</p>

</div>



</div>

<style>
    p.attribution {
        font-style: italic;
        font-size: 80%;
        text-align: right;
    }
    .body-container {
        margin: 0 10%;
        max-width: 55em;
        width: 80%;
    }
    a.toc-link {
      color: #aaa !important;
      font-size: 90%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .fixed-top-right {
        position: fixed;
        margin-top: 0;
        margin-left: 0;
    }
</style>

</main>
    <style>
#footer {
    font-size: 70%;
    color:green;
    text-align: center;
    font-style: italic;
    padding: 5px;
}
</style>
<div id="footer" class="mt-auto">
    All course materials ¬© Stanford University 2023</br>
    Notice regarding uploading to websites:  This content is protected and may not be shared, uploaded, or distributed.<BR>
    Website programming by Julie Zelenski &bull; Styles adapted from Chris Piech &bull;
    This page last updated 2023-Nov-13
</div>


  </body>

  <!-- Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

</html>
